import React, { useState, useEffect, useCallback } from 'react';
import { Heart, Eye, Shield, Gem, Map, RotateCcw, Home, ChevronUp, ChevronDown } from 'lucide-react';

const GRID_SIZE = 7;
const FLOORS = 3;
const DIFFICULTIES = {
  easy: { target: 5000, name: '이지' },
  normal: { target: 10000, name: '노말' },
  hard: { target: 20000, name: '하드' }
};

const CARD_TYPES = {
  HEAL: 'heal',
  TRAP_DISARM: 'trap_disarm', 
  MAP: 'map',
  SCORE: 'score',
  MULTIPLIER: 'multiplier_card'
};

const TILE_TYPES = {
  EMPTY: 'empty',
  TREASURE: 'treasure',
  TRAP: 'trap',
  BIG_TREASURE: 'big_treasure',
  MULTIPLIER: 'multiplier',
  CARD: 'card',
  STAIRS_UP: 'stairs_up',
  STAIRS_DOWN: 'stairs_down',
  ENTRANCE: 'entrance',
  FINAL_TREASURE: 'final_treasure',
  WALL: 'wall',
  POTION: 'potion'
};

function Loot1004Game() {
  const [difficulty, setDifficulty] = useState('normal');
  const [gameState, setGameState] = useState('menu'); // menu, playing, gameOver, victory
  const [floors, setFloors] = useState([]);
  const [revealed, setRevealed] = useState([]);
  const [currentFloor, setCurrentFloor] = useState(0);
  const [playerPos, setPlayerPos] = useState({ x: 3, y: 6 });
  const [entrancePos, setEntrancePos] = useState({ x: 3, y: 6 });
  const [health, setHealth] = useState(3);
  const [score, setScore] = useState(0);
  const [multiplier, setMultiplier] = useState(1);
  const [cards, setCards] = useState({ heal: 2, trap_disarm: 3, map: 2, multiplier_card: 1 });
  const [pendingTrap, setPendingTrap] = useState(null);
  const [pendingStairs, setPendingStairs] = useState(null);
  const [mapRevealed, setMapRevealed] = useState([]);
  const [floatingTexts, setFloatingTexts] = useState([]);
  const [pendingEscape, setPendingEscape] = useState(false);
  const [gameOverReason, setGameOverReason] = useState('death'); // 'death' or 'escape'
  const [disarmedTraps, setDisarmedTraps] = useState([]);
  const [wasAtEntrance, setWasAtEntrance] = useState(false);

  const initializeGame = useCallback(() => {
    // 입구 위치 랜덤 선택 (1층 가장자리)
    const edges = [
      { x: 0, y: 3 }, { x: 6, y: 3 }, // 좌우
      { x: 3, y: 0 }, { x: 3, y: 6 }  // 상하
    ];
    const entrance = edges[Math.floor(Math.random() * edges.length)];
    setEntrancePos(entrance);

    // 3층 던전 초기화
    const newFloors = [];
    const newRevealed = [];
    
    for (let floor = 0; floor < FLOORS; floor++) {
      const grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
      const revealedGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false));
      
      // 1층 (floor 0) - 입구 설정
      if (floor === 0) {
        grid[entrance.y][entrance.x] = TILE_TYPES.ENTRANCE;
        revealedGrid[entrance.y][entrance.x] = true;
        
        // 1층에 아래층으로 내려가는 계단 배치
        let stairsPlaced = false;
        while (!stairsPlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          if (x !== entrance.x || y !== entrance.y) {
            grid[y][x] = TILE_TYPES.STAIRS_DOWN;
            stairsPlaced = true;
          }
        }
      }
      
      // 2층 (floor 1) - 위아래 계단
      if (floor === 1) {
        // 위층으로 올라가는 계단
        let stairsUpPlaced = false;
        while (!stairsUpPlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          grid[y][x] = TILE_TYPES.STAIRS_UP;
          stairsUpPlaced = true;
        }
        
        // 아래층으로 내려가는 계단
        let stairsDownPlaced = false;
        while (!stairsDownPlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          if (grid[y][x] === null) {
            grid[y][x] = TILE_TYPES.STAIRS_DOWN;
            stairsDownPlaced = true;
          }
        }
      }
      
      // 3층 (floor 2) - 최종 보물과 위층 계단
      if (floor === 2) {
        // 위층으로 올라가는 계단
        let stairsUpPlaced = false;
        while (!stairsUpPlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          grid[y][x] = TILE_TYPES.STAIRS_UP;
          stairsUpPlaced = true;
        }
        
        // 최종 보물 배치
        let finalTreasurePlaced = false;
        while (!finalTreasurePlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          if (grid[y][x] === null) {
            grid[y][x] = TILE_TYPES.FINAL_TREASURE;
            finalTreasurePlaced = true;
          }
        }
      }
      
      // 나머지 타일 채우기
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] !== null) continue;
          
          const rand = Math.random();
          
          // 층별 난이도 조정 (함정과 포션 비율 고려)
          if (floor === 0) { // 1층 - 쉬움 (함정 10%, 포션 5%)
            if (rand < 0.05) grid[y][x] = TILE_TYPES.WALL;
            else if (rand < 0.15) grid[y][x] = TILE_TYPES.TRAP;
            else if (rand < 0.2) grid[y][x] = TILE_TYPES.POTION;
            else if (rand < 0.5) grid[y][x] = TILE_TYPES.EMPTY;
            else if (rand < 0.8) grid[y][x] = TILE_TYPES.TREASURE;
            else if (rand < 0.95) grid[y][x] = TILE_TYPES.CARD;
            else grid[y][x] = TILE_TYPES.MULTIPLIER;
          } else if (floor === 1) { // 2층 - 보통 (함정 20%, 포션 10%)
            if (rand < 0.1) grid[y][x] = TILE_TYPES.WALL;
            else if (rand < 0.3) grid[y][x] = TILE_TYPES.TRAP;
            else if (rand < 0.4) grid[y][x] = TILE_TYPES.POTION;
            else if (rand < 0.5) grid[y][x] = TILE_TYPES.EMPTY;
            else if (rand < 0.7) grid[y][x] = TILE_TYPES.TREASURE;
            else if (rand < 0.9) grid[y][x] = TILE_TYPES.BIG_TREASURE;
            else if (rand < 0.98) grid[y][x] = TILE_TYPES.CARD;
            else grid[y][x] = TILE_TYPES.MULTIPLIER;
          } else { // 3층 - 어려움 (함정 30%, 포션 15%)
            if (rand < 0.15) grid[y][x] = TILE_TYPES.WALL;
            else if (rand < 0.45) grid[y][x] = TILE_TYPES.TRAP;
            else if (rand < 0.6) grid[y][x] = TILE_TYPES.POTION;
            else if (rand < 0.65) grid[y][x] = TILE_TYPES.EMPTY;
            else if (rand < 0.8) grid[y][x] = TILE_TYPES.BIG_TREASURE;
            else if (rand < 0.95) grid[y][x] = TILE_TYPES.MULTIPLIER;
            else grid[y][x] = TILE_TYPES.CARD;
          }
          
          // 벽은 처음부터 공개
          if (grid[y][x] === TILE_TYPES.WALL) {
            revealedGrid[y][x] = true;
          }
        }
      }
      
      newFloors.push(grid);
      newRevealed.push(revealedGrid);
    }
    
    setFloors(newFloors);
    setRevealed(newRevealed);
    setCurrentFloor(0);
    setPlayerPos(entrance);
    setHealth(3);
    setScore(0);
    setMultiplier(1);
    setCards({ heal: 2, trap_disarm: 3, map: 2, multiplier_card: 1 });
    setPendingTrap(null);
    setPendingStairs(null);
    setMapRevealed([]);
    setFloatingTexts([]);
    setPendingEscape(false);
    setGameOverReason('death');
    setDisarmedTraps([]);
    setWasAtEntrance(true); // 시작지점이 입구이므로 true로 설정
    setGameState('playing');
  }, []);

  const addFloatingText = (text, color = 'text-yellow-400') => {
    const id = Date.now() + Math.random();
    setFloatingTexts(prev => [...prev, { id, text, color, opacity: 1 }]);
    
    // 3초 후 제거
    setTimeout(() => {
      setFloatingTexts(prev => prev.filter(ft => ft.id !== id));
    }, 3000);
  };

  const movePlayer = (dx, dy) => {
    if (gameState !== 'playing' || pendingTrap || pendingStairs || pendingEscape) return;
    
    const newX = playerPos.x + dx;
    const newY = playerPos.y + dy;
    
    if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) return;
    
    // 벽 체크 - 이동 차단
    const targetTile = floors[currentFloor][newY][newX];
    if (targetTile === TILE_TYPES.WALL) return;
    
    setPlayerPos({ x: newX, y: newY });
    
    // 타일 공개 여부 확인
    const wasRevealed = revealed[currentFloor][newY][newX];
    
    // 타일 공개
    if (!wasRevealed) {
      const newRevealed = [...revealed];
      newRevealed[currentFloor][newY][newX] = true;
      setRevealed(newRevealed);
    }
    
    // 타일 효과 처리
    const tileType = floors[currentFloor][newY][newX];
    if (tileType === TILE_TYPES.STAIRS_UP || tileType === TILE_TYPES.STAIRS_DOWN) {
      // 계단은 항상 처리
      handleTileEffect(tileType, newX, newY);
    } else if (!wasRevealed) {
      // 처음 공개되는 타일만 효과 처리
      handleTileEffect(tileType, newX, newY);
    }
    
    // 입구 도착 체크 - pendingEscape가 없을 때만
    const isAtEntrance = newX === entrancePos.x && newY === entrancePos.y && currentFloor === 0;
    
    if (isAtEntrance && !pendingEscape) {
      setPendingEscape(true);
    }
    
    setWasAtEntrance(isAtEntrance);
  };

  const handleTileEffect = (tileType, x, y) => {
    switch (tileType) {
      case TILE_TYPES.TREASURE:
        const treasureScore = Math.floor((50 + Math.random() * 100) * multiplier);
        setScore(prev => prev + treasureScore);
        addFloatingText(`+${treasureScore.toLocaleString()}`, 'text-yellow-400');
        break;
        
      case TILE_TYPES.BIG_TREASURE:
        const bigTreasureScore = Math.floor((200 + Math.random() * 300) * multiplier);
        setScore(prev => prev + bigTreasureScore);
        addFloatingText(`+${bigTreasureScore.toLocaleString()}`, 'text-orange-400');
        break;
        
      case TILE_TYPES.FINAL_TREASURE:
        const finalScore = Math.floor(1000 * multiplier);
        setScore(prev => prev + finalScore);
        addFloatingText(`+${finalScore.toLocaleString()}`, 'text-purple-400');
        break;
        
      case TILE_TYPES.MULTIPLIER:
        const multiplierScore = Math.floor(100 * multiplier);
        setScore(prev => prev + multiplierScore);
        addFloatingText(`+${multiplierScore.toLocaleString()}`, 'text-purple-400');
        // 배수증가 카드 획득
        setCards(prev => ({ ...prev, multiplier_card: prev.multiplier_card + 1 }));
        addFloatingText('배수증가 카드 획득!', 'text-green-400');
        break;
        
      case TILE_TYPES.CARD:
        const cardTypes = Object.values(CARD_TYPES);
        const randomCard = cardTypes[Math.floor(Math.random() * cardTypes.length)];
        setCards(prev => ({ ...prev, [randomCard]: prev[randomCard] + 1 }));
        addFloatingText('카드 획득!', 'text-blue-400');
        break;
        
      case TILE_TYPES.STAIRS_UP:
        if (currentFloor > 0) {
          setPendingStairs({ type: 'up', x, y });
        }
        break;
        
      case TILE_TYPES.STAIRS_DOWN:
        if (currentFloor < FLOORS - 1) {
          setPendingStairs({ type: 'down', x, y });
        }
        break;
        
      case TILE_TYPES.TRAP:
        setPendingTrap({ x, y });
        break;
        
      case TILE_TYPES.POTION:
        // 회복 카드 획득
        setCards(prev => ({ ...prev, heal: prev.heal + 1 }));
        addFloatingText('회복 카드 획득!', 'text-green-400');
        break;
    }
  };

  const useStairs = () => {
    if (!pendingStairs) return;
    
    if (pendingStairs.type === 'up' && currentFloor > 0) {
      setCurrentFloor(prev => prev - 1);
      // 올라가는 계단의 대응 계단 찾기
      const upperFloor = floors[currentFloor - 1];
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (upperFloor[y][x] === TILE_TYPES.STAIRS_DOWN) {
            setPlayerPos({ x, y });
            break;
          }
        }
      }
    } else if (pendingStairs.type === 'down' && currentFloor < FLOORS - 1) {
      const currentPos = { x: pendingStairs.x, y: pendingStairs.y };
      setCurrentFloor(prev => prev + 1);
      
      // 내려간 위치에 올라가기 계단 생성
      const newFloors = [...floors];
      newFloors[currentFloor + 1][currentPos.y][currentPos.x] = TILE_TYPES.STAIRS_UP;
      setFloors(newFloors);
      
      // 플레이어도 같은 위치로 이동
      setPlayerPos(currentPos);
    }
    
    setPendingStairs(null);
  };

  const useMultiplierCard = () => {
    if (cards.multiplier_card > 0) {
      setCards(prev => ({ ...prev, multiplier_card: prev.multiplier_card - 1 }));
      setMultiplier(prev => prev + 1.0);
      addFloatingText(`배수 증가! ×${multiplier + 1.0}`, 'text-green-400');
    }
  };

  const useTrapDisarm = () => {
    if (cards.trap_disarm > 0 && pendingTrap) {
      setCards(prev => ({ ...prev, trap_disarm: prev.trap_disarm - 1 }));
      // 해제된 함정 목록에 추가
      setDisarmedTraps(prev => [...prev, `${currentFloor},${pendingTrap.x},${pendingTrap.y}`]);
      // 함정해제 카드를 써도 강제 데미지
      setHealth(prev => {
        const newHealth = prev - 1;
        if (newHealth <= 0) {
          setGameOverReason('death');
          setGameState('gameOver');
          return 0;
        }
        return newHealth;
      });
      setMultiplier(1); // 배수 초기화
      addFloatingText('-1 체력', 'text-red-400');
      addFloatingText('배수 초기화!', 'text-red-400');
      setPendingTrap(null);
    }
  };

  const takeTrapDamage = () => {
    setHealth(prev => {
      const newHealth = prev - 1;
      if (newHealth <= 0) {
        setGameOverReason('death');
        setGameState('gameOver');
        return 0;
      }
      return newHealth;
    });
    setMultiplier(1); // 배수 초기화
    addFloatingText('-1 체력', 'text-red-400');
    addFloatingText('배수 초기화!', 'text-red-400');
    setPendingTrap(null);
  };

  const useHeal = () => {
    if (cards.heal > 0 && health < 3) {
      setCards(prev => ({ ...prev, heal: prev.heal - 1 }));
      setHealth(prev => Math.min(prev + 1, 3));
      addFloatingText('+1 체력', 'text-green-400');
    }
  };

  const useMap = () => {
    if (cards.map > 0) {
      setCards(prev => ({ ...prev, map: prev.map - 1 }));
      
      // 주변 3x3 영역 공개
      const newMapRevealed = [...mapRevealed];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const x = playerPos.x + dx;
          const y = playerPos.y + dy;
          if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
            newMapRevealed.push(`${currentFloor},${x},${y}`);
          }
        }
      }
      setMapRevealed(newMapRevealed);
      addFloatingText('지도 사용!', 'text-purple-400');
    }
  };

  const checkEscape = () => {
    if (playerPos.x === entrancePos.x && playerPos.y === entrancePos.y && currentFloor === 0) {
      setPendingEscape(true);
    }
  };

  const confirmEscape = () => {
    const target = DIFFICULTIES[difficulty].target;
    setGameOverReason('escape');
    
    if (score >= target) {
      setGameState('victory');
    } else {
      setGameState('gameOver');
    }
    setPendingEscape(false);
  };

  const getTileDisplay = (x, y) => {
    const isRevealed = revealed[currentFloor][y][x];
    const isPlayer = playerPos.x === x && playerPos.y === y;
    const isMapRevealed = mapRevealed.includes(`${currentFloor},${x},${y}`) && !isRevealed;
    const isEntrance = x === entrancePos.x && y === entrancePos.y && currentFloor === 0;
    const isDisarmedTrap = disarmedTraps.includes(`${currentFloor},${x},${y}`);
    
    if (isPlayer) {
      return <div className="w-6 h-6 bg-blue-500 rounded-full border-2 border-white"></div>;
    }
    
    if (!isRevealed && !isMapRevealed) {
      return <div className="w-full h-full bg-gray-600"></div>;
    }
    
    if (isMapRevealed) {
      const tileType = floors[currentFloor][y][x];
      let bgColor = 'bg-gray-400';
      let icon = null;
      
      switch (tileType) {
        case TILE_TYPES.TRAP:
          if (isDisarmedTrap) {
            bgColor = 'bg-gray-400';
            icon = null; // 주의 표시 숨김
          } else {
            bgColor = 'bg-red-300';
            icon = <span className="text-red-600 text-xs">⚠</span>;
          }
          break;
        case TILE_TYPES.TREASURE:
          bgColor = 'bg-yellow-300';
          icon = <Gem className="w-3 h-3 text-yellow-600" />;
          break;
        case TILE_TYPES.BIG_TREASURE:
          bgColor = 'bg-orange-300';
          icon = <Gem className="w-4 h-4 text-orange-600" />;
          break;
        case TILE_TYPES.FINAL_TREASURE:
          bgColor = 'bg-purple-300';
          icon = <Gem className="w-5 h-5 text-purple-600" />;
          break;
        case TILE_TYPES.MULTIPLIER:
          bgColor = 'bg-purple-300';
          icon = <span className="text-purple-600 text-xs">×</span>;
          break;
        case TILE_TYPES.CARD:
          bgColor = 'bg-blue-300';
          icon = <span className="text-blue-600 text-xs">📄</span>;
          break;
        case TILE_TYPES.STAIRS_UP:
          bgColor = 'bg-green-300';
          icon = <ChevronUp className="w-3 h-3 text-green-600" />;
          break;
        case TILE_TYPES.STAIRS_DOWN:
          bgColor = 'bg-green-300';
          icon = <ChevronDown className="w-3 h-3 text-green-600" />;
          break;
        case TILE_TYPES.WALL:
          bgColor = 'bg-gray-600';
          icon = <span className="text-gray-800 text-xs">■</span>;
          break;
        case TILE_TYPES.POTION:
          bgColor = 'bg-pink-300';
          icon = <Heart className="w-3 h-3 text-pink-600" />;
          break;
        default:
          break;
      }
      
      return <div className={`w-full h-full ${bgColor} flex items-center justify-center opacity-70`}>{icon}</div>;
    }
    
    if (isEntrance && isRevealed) {
      return <div className="w-full h-full bg-green-500 flex items-center justify-center">
        <Home className="w-4 h-4 text-white" />
      </div>;
    }
    
    const tileType = floors[currentFloor][y][x];
    let bgColor = 'bg-gray-300';
    let icon = null;
    
    switch (tileType) {
      case TILE_TYPES.EMPTY:
        bgColor = 'bg-gray-300';
        break;
      case TILE_TYPES.ENTRANCE:
        bgColor = 'bg-green-500';
        icon = <Home className="w-4 h-4 text-white" />;
        break;
      case TILE_TYPES.TRAP:
        if (isDisarmedTrap) {
          bgColor = 'bg-gray-300';
          icon = null; // 주의 표시 숨김
        } else {
          bgColor = 'bg-red-500';
          icon = <span className="text-white text-sm">⚠</span>;
        }
        break;
      case TILE_TYPES.TREASURE:
        bgColor = 'bg-yellow-500';
        icon = <Gem className="w-4 h-4 text-white" />;
        break;
      case TILE_TYPES.BIG_TREASURE:
        bgColor = 'bg-orange-500';
        icon = <Gem className="w-5 h-5 text-white" />;
        break;
      case TILE_TYPES.FINAL_TREASURE:
        bgColor = 'bg-purple-600';
        icon = <Gem className="w-6 h-6 text-white" />;
        break;
      case TILE_TYPES.MULTIPLIER:
        bgColor = 'bg-purple-500';
        icon = <span className="text-white font-bold">×</span>;
        break;
      case TILE_TYPES.CARD:
        bgColor = 'bg-blue-500';
        icon = <span className="text-white">📄</span>;
        break;
      case TILE_TYPES.STAIRS_UP:
        bgColor = 'bg-green-600';
        icon = <ChevronUp className="w-4 h-4 text-white" />;
        break;
      case TILE_TYPES.STAIRS_DOWN:
        bgColor = 'bg-green-600';
        icon = <ChevronDown className="w-4 h-4 text-white" />;
        break;
      case TILE_TYPES.WALL:
        bgColor = 'bg-gray-800';
        icon = <span className="text-gray-600 font-bold">■</span>;
        break;
      case TILE_TYPES.POTION:
        bgColor = 'bg-pink-500';
        icon = <Heart className="w-4 h-4 text-white" />;
        break;
      default:
        break;
    }
    
    return <div className={`w-full h-full ${bgColor} flex items-center justify-center`}>{icon}</div>;
  };

  // 카드 컴포넌트
  const CardComponent = ({ type, count, onClick, disabled }) => {
    const getCardInfo = () => {
      switch (type) {
        case 'heal':
          return { name: '회복', icon: Heart, color: 'bg-red-500', hotkey: '1' };
        case 'trap_disarm':
          return { name: '함정해제', icon: Shield, color: 'bg-blue-500', hotkey: '2' };
        case 'map':
          return { name: '지도', icon: Map, color: 'bg-purple-500', hotkey: '3' };
        case 'multiplier_card':
          return { name: '배수증가', icon: () => <span className="text-white font-bold">×+</span>, color: 'bg-green-500', hotkey: '4' };
        default:
          return { name: '카드', icon: Eye, color: 'bg-gray-500', hotkey: '' };
      }
    };

    const { name, icon: IconComponent, color, hotkey } = getCardInfo();

    return (
      <div 
        className={`relative p-3 rounded-lg border-2 cursor-pointer transition-all ${
          disabled 
            ? 'bg-gray-700 border-gray-600 opacity-50 cursor-not-allowed' 
            : `${color} border-white hover:scale-105 hover:shadow-lg`
        }`}
        onClick={!disabled ? onClick : undefined}
      >
        {/* 카드 상단 */}
        <div className="flex items-center justify-between mb-2">
          {typeof IconComponent === 'function' ? <IconComponent /> : <IconComponent className="w-5 h-5 text-white" />}
          <span className="text-white font-bold text-lg">{count}</span>
        </div>
        
        {/* 카드 하단 */}
        <div className="text-center">
          <div className="text-white font-semibold text-sm">{name}</div>
          <div className="text-white text-xs opacity-75">[{hotkey}]</div>
        </div>
        
        {/* 카드 테두리 효과 */}
        <div className="absolute inset-0 rounded-lg border border-white opacity-20"></div>
      </div>
    );
  };

  // 키보드 입력 처리
  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameState !== 'playing') return;
      
      switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          movePlayer(0, -1);
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          movePlayer(0, 1);
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          movePlayer(-1, 0);
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          movePlayer(1, 0);
          break;
        case '1':
          useHeal();
          break;
        case '2':
          useTrapDisarm();
          break;
        case '3':
          useMap();
          break;
        case '4':
          useMultiplierCard();
          break;
        case 'r':
          if (playerPos.x === entrancePos.x && playerPos.y === entrancePos.y && currentFloor === 0) {
            setPendingEscape(true);
          }
          break;
        case 'Enter':
        case ' ':
          if (pendingStairs) useStairs();
          else if (pendingEscape) confirmEscape();
          break;
        default:
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState, playerPos, cards, health, currentFloor, pendingStairs]);

  if (gameState === 'menu') {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white p-8">
        <h1 className="text-4xl font-bold mb-8 text-yellow-400">LOOT1004 리메이크</h1>
        <div className="mb-8">
          <h2 className="text-xl mb-4">난이도 선택:</h2>
          {Object.entries(DIFFICULTIES).map(([key, diff]) => (
            <div key={key} className="mb-2">
              <button
                onClick={() => setDifficulty(key)}
                className={`px-4 py-2 rounded mr-4 ${
                  difficulty === key ? 'bg-yellow-600' : 'bg-gray-700 hover:bg-gray-600'
                }`}
              >
                {diff.name}
              </button>
              <span>목표: {diff.target.toLocaleString()}점</span>
            </div>
          ))}
        </div>
        <button
          onClick={initializeGame}
          className="px-6 py-3 bg-green-600 hover:bg-green-700 rounded text-xl font-bold"
        >
          게임 시작
        </button>
        <div className="mt-8 text-sm text-gray-400 max-w-md text-center">
          <h3 className="font-bold mb-2 text-white">조작법</h3>
          <p>• WASD / 화살표키로 이동</p>
          <p>• 1/2/3/4: 카드 사용</p>
          <p>• R: 입구에서 탈출</p>
          <p>• Enter/Space: 계단/탈출 확인</p>
          <div className="mt-4 border-t border-gray-600 pt-4">
            <p>• 3층 던전을 탐험하고 입구로 돌아오세요</p>
            <p>• 함정을 밟으면 무조건 데미지를 받습니다</p>
            <p>• 데미지를 받으면 배수가 1로 초기화됩니다</p>
            <p>• 체력이 0이 되면 게임오버</p>
          </div>
        </div>
      </div>
    );
  }

  if (gameState === 'gameOver') {
    if (gameOverReason === 'death') {
      return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white">
          <h1 className="text-4xl font-bold mb-4 text-red-500">게임 오버</h1>
          <p className="text-xl mb-2 text-red-400">최종 점수: 0점 (탈출 실패)</p>
          <p className="text-lg mb-2 text-red-400">획득 금액: 0원</p>
          <p className="text-lg mb-8">목표: {DIFFICULTIES[difficulty].target.toLocaleString()}점</p>
          <button
            onClick={() => setGameState('menu')}
            className="px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded"
          >
            메뉴로 돌아가기
          </button>
        </div>
      );
    } else {
      // 탈출 성공했지만 목표 점수 미달
      const money = Math.floor(score * 0.1);
      return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white">
          <h1 className="text-4xl font-bold mb-4 text-yellow-500">탈출 성공!</h1>
          <p className="text-xl mb-2">최종 점수: {score.toLocaleString()}점</p>
          <p className="text-lg mb-2 text-green-400">획득 금액: {money.toLocaleString()}원</p>
          <p className="text-lg mb-4 text-red-400">목표 미달: {DIFFICULTIES[difficulty].target.toLocaleString()}점</p>
          <p className="text-sm mb-8 text-gray-400">목표 점수를 달성해야 완전한 승리입니다!</p>
          <button
            onClick={() => setGameState('menu')}
            className="px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded"
          >
            메뉴로 돌아가기
          </button>
        </div>
      );
    }
  }

  if (gameState === 'victory') {
    const money = Math.floor(score * 0.1);
    return (
      <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white">
        <h1 className="text-4xl font-bold mb-4 text-green-500">승리!</h1>
        <p className="text-xl mb-2">최종 점수: {score.toLocaleString()}점</p>
        <p className="text-lg mb-2 text-green-400">획득 금액: {money.toLocaleString()}원</p>
        <p className="text-lg mb-8">목표 달성: {DIFFICULTIES[difficulty].target.toLocaleString()}점</p>
        <button
          onClick={() => setGameState('menu')}
          className="px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded"
        >
          메뉴로 돌아가기
        </button>
      </div>
    );
  }

  if (floors.length === 0) return <div>로딩 중...</div>;

  return (
    <div className="min-h-screen bg-gray-900 text-white p-4">
      <style jsx>{`
        @keyframes fadeUp {
          0% {
            opacity: 1;
            transform: translate(-50%, 0px);
          }
          100% {
            opacity: 0;
            transform: translate(-50%, -50px);
          }
        }
      `}</style>
      
      {/* 상단 배수 표시 제거 */}
      
      {/* 함정 대화상자 */}
      {pendingTrap && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded border-2 border-red-500">
            <h3 className="text-xl font-bold text-red-500 mb-4">함정 발견!</h3>
            <p className="mb-4">어떤 선택을 하든 1의 데미지를 받습니다!</p>
            <div className="flex space-x-4">
              <button
                onClick={useTrapDisarm}
                disabled={cards.trap_disarm === 0}
                className={`px-4 py-2 rounded ${
                  cards.trap_disarm > 0 
                    ? 'bg-green-600 hover:bg-green-700' 
                    : 'bg-gray-600 cursor-not-allowed'
                }`}
              >
                해제 카드 사용 ({cards.trap_disarm})
              </button>
              <button
                onClick={takeTrapDamage}
                className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded"
              >
                그냥 받기
              </button>
            </div>
          </div>
        </div>
      )}

      {/* 탈출 확인 대화상자 */}
      {pendingEscape && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded border-2 border-yellow-500">
            <h3 className="text-xl font-bold text-yellow-500 mb-4">입구 발견!</h3>
            <div className="mb-4">
              <p>탈출하시겠습니까?</p>
              <p className="text-sm mt-2">현재 점수: {score.toLocaleString()}점</p>
              <p className="text-green-400 text-sm">획득 금액: {Math.floor(score * 0.1).toLocaleString()}원</p>
            </div>
            <div className="flex space-x-4">
              <button
                onClick={confirmEscape}
                className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded"
              >
                탈출하기 [Enter/Space]
              </button>
              <button
                onClick={() => setPendingEscape(false)}
                className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded"
              >
                계속 탐험
              </button>
            </div>
          </div>
        </div>
      )}

      {/* 계단 대화상자 */}
      {pendingStairs && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded border-2 border-green-500">
            <h3 className="text-xl font-bold text-green-500 mb-4">계단 발견!</h3>
            <p className="mb-4">
              {pendingStairs.type === 'up' 
                ? `${currentFloor}층으로 올라가시겠습니까?` 
                : `${currentFloor + 2}층으로 내려가시겠습니까?`}
            </p>
            <div className="flex space-x-4">
              <button
                onClick={useStairs}
                className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded"
              >
                {pendingStairs.type === 'up' ? '올라가기' : '내려가기'} [Enter/Space]
              </button>
              <button
                onClick={() => setPendingStairs(null)}
                className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded"
              >
                취소
              </button>
            </div>
          </div>
        </div>
      )}

      {/* 플로팅 텍스트 제거 */}

      <div className="flex gap-4">
        {/* 왼쪽: 게임 보드와 카드 */}
        <div className="flex gap-4">
          {/* 게임 보드 */}
          <div className="flex-1">
            <div className="mb-4 flex items-center justify-center gap-4">
              <h2 className="text-2xl font-bold text-yellow-400">{currentFloor + 1}층</h2>
              <div className="bg-purple-600 px-4 py-1 rounded-lg border-2 border-purple-400">
                <span className="text-lg font-bold text-white">배수: ×{multiplier}</span>
              </div>
              {/* 탈출 버튼 */}
              {playerPos.x === entrancePos.x && playerPos.y === entrancePos.y && currentFloor === 0 && (
                <button
                  onClick={() => setPendingEscape(true)}
                  className="px-3 py-1 bg-yellow-600 hover:bg-yellow-700 rounded flex items-center text-sm"
                >
                  <Home className="w-4 h-4 mr-1" />
                  탈출 [R]
                </button>
              )}
            </div>
            <div className="grid grid-cols-7 gap-1 bg-gray-700 p-4 rounded max-w-md mx-auto">
              {floors[currentFloor].map((row, y) =>
                row.map((_, x) => (
                  <div
                    key={`${x}-${y}`}
                    className="w-10 h-10 border border-gray-500 flex items-center justify-center"
                  >
                    {getTileDisplay(x, y)}
                  </div>
                ))
              )}
            </div>
            
            {/* 상태창 - 맵 하단 */}
            <div className="bg-gray-800 p-4 rounded mt-4 max-w-md mx-auto">
              <div className="flex items-center justify-between mb-2">
                <h3 className="text-lg font-bold">상태</h3>
                <div className="text-sm">
                  <span className="text-gray-400">획득정보: </span>
                  <span className="text-yellow-400">
                    {floatingTexts.length > 0 ? floatingTexts[floatingTexts.length - 1].text : '없음'}
                  </span>
                </div>
              </div>
              <div className="grid grid-cols-2 gap-4">
                {/* 왼쪽: 체력, 점수, 배수 */}
                <div className="space-y-2">
                  <div className="flex items-center">
                    <Heart className="w-5 h-5 text-red-500 mr-2" />
                    <span>체력: {health}/3</span>
                  </div>
                  <div>점수: {score.toLocaleString()}</div>
                  <div className="text-yellow-400">배수: ×{multiplier}</div>
                </div>
                
                {/* 오른쪽: 층, 목표 */}
                <div className="space-y-2">
                  <div>층: {currentFloor + 1}/3</div>
                  <div>목표: {DIFFICULTIES[difficulty].target.toLocaleString()}</div>
                </div>
              </div>
            </div>
          </div>

          {/* 카드창 - 맵 오른쪽에 바로 붙여서 배치 */}
          <div className="w-40 space-y-3">
            <h3 className="text-lg font-bold text-center text-white">카드</h3>
            <CardComponent 
              type="heal" 
              count={cards.heal}
              onClick={useHeal}
              disabled={cards.heal === 0 || health === 3}
            />
            <CardComponent 
              type="trap_disarm" 
              count={cards.trap_disarm}
              onClick={useTrapDisarm}
              disabled={cards.trap_disarm === 0 || !pendingTrap}
            />
            <CardComponent 
              type="map" 
              count={cards.map}
              onClick={useMap}
              disabled={cards.map === 0}
            />
            <CardComponent 
              type="multiplier_card" 
              count={cards.multiplier_card}
              onClick={useMultiplierCard}
              disabled={cards.multiplier_card === 0}
            />
          </div>
        </div>

        {/* 중간: 빈 공간 */}
        <div className="w-20">
        </div>

        {/* 오른쪽: 빈 공간 (기존 카드 자리) */}
        <div className="w-40">
        </div>
      </div>
    </div>
  );
}

export default Loot1004Game;
