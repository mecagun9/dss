import React, { useState, useEffect, useCallback } from 'react';
import { Heart, Eye, Shield, Gem, Map, RotateCcw, Home, ChevronUp, ChevronDown } from 'lucide-react';

const GRID_SIZE = 7;
const FLOORS = 3;
const DIFFICULTIES = {
  easy: { target: 5000, name: 'ì´ì§€' },
  normal: { target: 10000, name: 'ë…¸ë§' },
  hard: { target: 20000, name: 'í•˜ë“œ' }
};

const CARD_TYPES = {
  HEAL: 'heal',
  TRAP_DISARM: 'trap_disarm', 
  MAP: 'map',
  SCORE: 'score',
  MULTIPLIER: 'multiplier_card'
};

const TILE_TYPES = {
  EMPTY: 'empty',
  TREASURE: 'treasure',
  TRAP: 'trap',
  BIG_TREASURE: 'big_treasure',
  MULTIPLIER: 'multiplier',
  CARD: 'card',
  STAIRS_UP: 'stairs_up',
  STAIRS_DOWN: 'stairs_down',
  ENTRANCE: 'entrance',
  FINAL_TREASURE: 'final_treasure',
  WALL: 'wall',
  POTION: 'potion'
};

function Loot1004Game() {
  const [difficulty, setDifficulty] = useState('normal');
  const [gameState, setGameState] = useState('menu'); // menu, playing, gameOver, victory
  const [floors, setFloors] = useState([]);
  const [revealed, setRevealed] = useState([]);
  const [currentFloor, setCurrentFloor] = useState(0);
  const [playerPos, setPlayerPos] = useState({ x: 3, y: 6 });
  const [entrancePos, setEntrancePos] = useState({ x: 3, y: 6 });
  const [health, setHealth] = useState(3);
  const [score, setScore] = useState(0);
  const [multiplier, setMultiplier] = useState(1);
  const [cards, setCards] = useState({ heal: 2, trap_disarm: 3, map: 2, multiplier_card: 1 });
  const [pendingTrap, setPendingTrap] = useState(null);
  const [pendingStairs, setPendingStairs] = useState(null);
  const [mapRevealed, setMapRevealed] = useState([]);
  const [floatingTexts, setFloatingTexts] = useState([]);
  const [pendingEscape, setPendingEscape] = useState(false);
  const [gameOverReason, setGameOverReason] = useState('death'); // 'death' or 'escape'
  const [disarmedTraps, setDisarmedTraps] = useState([]);
  const [wasAtEntrance, setWasAtEntrance] = useState(false);

  const initializeGame = useCallback(() => {
    // ì…êµ¬ ìœ„ì¹˜ ëœë¤ ì„ íƒ (1ì¸µ ê°€ì¥ìë¦¬)
    const edges = [
      { x: 0, y: 3 }, { x: 6, y: 3 }, // ì¢Œìš°
      { x: 3, y: 0 }, { x: 3, y: 6 }  // ìƒí•˜
    ];
    const entrance = edges[Math.floor(Math.random() * edges.length)];
    setEntrancePos(entrance);

    // 3ì¸µ ë˜ì „ ì´ˆê¸°í™”
    const newFloors = [];
    const newRevealed = [];
    
    for (let floor = 0; floor < FLOORS; floor++) {
      const grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
      const revealedGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false));
      
      // 1ì¸µ (floor 0) - ì…êµ¬ ì„¤ì •
      if (floor === 0) {
        grid[entrance.y][entrance.x] = TILE_TYPES.ENTRANCE;
        revealedGrid[entrance.y][entrance.x] = true;
        
        // 1ì¸µì— ì•„ë˜ì¸µìœ¼ë¡œ ë‚´ë ¤ê°€ëŠ” ê³„ë‹¨ ë°°ì¹˜
        let stairsPlaced = false;
        while (!stairsPlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          if (x !== entrance.x || y !== entrance.y) {
            grid[y][x] = TILE_TYPES.STAIRS_DOWN;
            stairsPlaced = true;
          }
        }
      }
      
      // 2ì¸µ (floor 1) - ìœ„ì•„ë˜ ê³„ë‹¨
      if (floor === 1) {
        // ìœ„ì¸µìœ¼ë¡œ ì˜¬ë¼ê°€ëŠ” ê³„ë‹¨
        let stairsUpPlaced = false;
        while (!stairsUpPlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          grid[y][x] = TILE_TYPES.STAIRS_UP;
          stairsUpPlaced = true;
        }
        
        // ì•„ë˜ì¸µìœ¼ë¡œ ë‚´ë ¤ê°€ëŠ” ê³„ë‹¨
        let stairsDownPlaced = false;
        while (!stairsDownPlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          if (grid[y][x] === null) {
            grid[y][x] = TILE_TYPES.STAIRS_DOWN;
            stairsDownPlaced = true;
          }
        }
      }
      
      // 3ì¸µ (floor 2) - ìµœì¢… ë³´ë¬¼ê³¼ ìœ„ì¸µ ê³„ë‹¨
      if (floor === 2) {
        // ìœ„ì¸µìœ¼ë¡œ ì˜¬ë¼ê°€ëŠ” ê³„ë‹¨
        let stairsUpPlaced = false;
        while (!stairsUpPlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          grid[y][x] = TILE_TYPES.STAIRS_UP;
          stairsUpPlaced = true;
        }
        
        // ìµœì¢… ë³´ë¬¼ ë°°ì¹˜
        let finalTreasurePlaced = false;
        while (!finalTreasurePlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          if (grid[y][x] === null) {
            grid[y][x] = TILE_TYPES.FINAL_TREASURE;
            finalTreasurePlaced = true;
          }
        }
      }
      
      // ë‚˜ë¨¸ì§€ íƒ€ì¼ ì±„ìš°ê¸°
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (grid[y][x] !== null) continue;
          
          const rand = Math.random();
          
          // ì¸µë³„ ë‚œì´ë„ ì¡°ì • (í•¨ì •ê³¼ í¬ì…˜ ë¹„ìœ¨ ê³ ë ¤)
          if (floor === 0) { // 1ì¸µ - ì‰¬ì›€ (í•¨ì • 10%, í¬ì…˜ 5%)
            if (rand < 0.05) grid[y][x] = TILE_TYPES.WALL;
            else if (rand < 0.15) grid[y][x] = TILE_TYPES.TRAP;
            else if (rand < 0.2) grid[y][x] = TILE_TYPES.POTION;
            else if (rand < 0.5) grid[y][x] = TILE_TYPES.EMPTY;
            else if (rand < 0.8) grid[y][x] = TILE_TYPES.TREASURE;
            else if (rand < 0.95) grid[y][x] = TILE_TYPES.CARD;
            else grid[y][x] = TILE_TYPES.MULTIPLIER;
          } else if (floor === 1) { // 2ì¸µ - ë³´í†µ (í•¨ì • 20%, í¬ì…˜ 10%)
            if (rand < 0.1) grid[y][x] = TILE_TYPES.WALL;
            else if (rand < 0.3) grid[y][x] = TILE_TYPES.TRAP;
            else if (rand < 0.4) grid[y][x] = TILE_TYPES.POTION;
            else if (rand < 0.5) grid[y][x] = TILE_TYPES.EMPTY;
            else if (rand < 0.7) grid[y][x] = TILE_TYPES.TREASURE;
            else if (rand < 0.9) grid[y][x] = TILE_TYPES.BIG_TREASURE;
            else if (rand < 0.98) grid[y][x] = TILE_TYPES.CARD;
            else grid[y][x] = TILE_TYPES.MULTIPLIER;
          } else { // 3ì¸µ - ì–´ë ¤ì›€ (í•¨ì • 30%, í¬ì…˜ 15%)
            if (rand < 0.15) grid[y][x] = TILE_TYPES.WALL;
            else if (rand < 0.45) grid[y][x] = TILE_TYPES.TRAP;
            else if (rand < 0.6) grid[y][x] = TILE_TYPES.POTION;
            else if (rand < 0.65) grid[y][x] = TILE_TYPES.EMPTY;
            else if (rand < 0.8) grid[y][x] = TILE_TYPES.BIG_TREASURE;
            else if (rand < 0.95) grid[y][x] = TILE_TYPES.MULTIPLIER;
            else grid[y][x] = TILE_TYPES.CARD;
          }
          
          // ë²½ì€ ì²˜ìŒë¶€í„° ê³µê°œ
          if (grid[y][x] === TILE_TYPES.WALL) {
            revealedGrid[y][x] = true;
          }
        }
      }
      
      newFloors.push(grid);
      newRevealed.push(revealedGrid);
    }
    
    setFloors(newFloors);
    setRevealed(newRevealed);
    setCurrentFloor(0);
    setPlayerPos(entrance);
    setHealth(3);
    setScore(0);
    setMultiplier(1);
    setCards({ heal: 2, trap_disarm: 3, map: 2, multiplier_card: 1 });
    setPendingTrap(null);
    setPendingStairs(null);
    setMapRevealed([]);
    setFloatingTexts([]);
    setPendingEscape(false);
    setGameOverReason('death');
    setDisarmedTraps([]);
    setWasAtEntrance(true); // ì‹œì‘ì§€ì ì´ ì…êµ¬ì´ë¯€ë¡œ trueë¡œ ì„¤ì •
    setGameState('playing');
  }, []);

  const addFloatingText = (text, color = 'text-yellow-400') => {
    const id = Date.now() + Math.random();
    setFloatingTexts(prev => [...prev, { id, text, color, opacity: 1 }]);
    
    // 3ì´ˆ í›„ ì œê±°
    setTimeout(() => {
      setFloatingTexts(prev => prev.filter(ft => ft.id !== id));
    }, 3000);
  };

  const movePlayer = (dx, dy) => {
    if (gameState !== 'playing' || pendingTrap || pendingStairs || pendingEscape) return;
    
    const newX = playerPos.x + dx;
    const newY = playerPos.y + dy;
    
    if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) return;
    
    // ë²½ ì²´í¬ - ì´ë™ ì°¨ë‹¨
    const targetTile = floors[currentFloor][newY][newX];
    if (targetTile === TILE_TYPES.WALL) return;
    
    setPlayerPos({ x: newX, y: newY });
    
    // íƒ€ì¼ ê³µê°œ ì—¬ë¶€ í™•ì¸
    const wasRevealed = revealed[currentFloor][newY][newX];
    
    // íƒ€ì¼ ê³µê°œ
    if (!wasRevealed) {
      const newRevealed = [...revealed];
      newRevealed[currentFloor][newY][newX] = true;
      setRevealed(newRevealed);
    }
    
    // íƒ€ì¼ íš¨ê³¼ ì²˜ë¦¬
    const tileType = floors[currentFloor][newY][newX];
    if (tileType === TILE_TYPES.STAIRS_UP || tileType === TILE_TYPES.STAIRS_DOWN) {
      // ê³„ë‹¨ì€ í•­ìƒ ì²˜ë¦¬
      handleTileEffect(tileType, newX, newY);
    } else if (!wasRevealed) {
      // ì²˜ìŒ ê³µê°œë˜ëŠ” íƒ€ì¼ë§Œ íš¨ê³¼ ì²˜ë¦¬
      handleTileEffect(tileType, newX, newY);
    }
    
    // ì…êµ¬ ë„ì°© ì²´í¬ - pendingEscapeê°€ ì—†ì„ ë•Œë§Œ
    const isAtEntrance = newX === entrancePos.x && newY === entrancePos.y && currentFloor === 0;
    
    if (isAtEntrance && !pendingEscape) {
      setPendingEscape(true);
    }
    
    setWasAtEntrance(isAtEntrance);
  };

  const handleTileEffect = (tileType, x, y) => {
    switch (tileType) {
      case TILE_TYPES.TREASURE:
        const treasureScore = Math.floor((50 + Math.random() * 100) * multiplier);
        setScore(prev => prev + treasureScore);
        addFloatingText(`+${treasureScore.toLocaleString()}`, 'text-yellow-400');
        break;
        
      case TILE_TYPES.BIG_TREASURE:
        const bigTreasureScore = Math.floor((200 + Math.random() * 300) * multiplier);
        setScore(prev => prev + bigTreasureScore);
        addFloatingText(`+${bigTreasureScore.toLocaleString()}`, 'text-orange-400');
        break;
        
      case TILE_TYPES.FINAL_TREASURE:
        const finalScore = Math.floor(1000 * multiplier);
        setScore(prev => prev + finalScore);
        addFloatingText(`+${finalScore.toLocaleString()}`, 'text-purple-400');
        break;
        
      case TILE_TYPES.MULTIPLIER:
        const multiplierScore = Math.floor(100 * multiplier);
        setScore(prev => prev + multiplierScore);
        addFloatingText(`+${multiplierScore.toLocaleString()}`, 'text-purple-400');
        // ë°°ìˆ˜ì¦ê°€ ì¹´ë“œ íšë“
        setCards(prev => ({ ...prev, multiplier_card: prev.multiplier_card + 1 }));
        addFloatingText('ë°°ìˆ˜ì¦ê°€ ì¹´ë“œ íšë“!', 'text-green-400');
        break;
        
      case TILE_TYPES.CARD:
        const cardTypes = Object.values(CARD_TYPES);
        const randomCard = cardTypes[Math.floor(Math.random() * cardTypes.length)];
        setCards(prev => ({ ...prev, [randomCard]: prev[randomCard] + 1 }));
        addFloatingText('ì¹´ë“œ íšë“!', 'text-blue-400');
        break;
        
      case TILE_TYPES.STAIRS_UP:
        if (currentFloor > 0) {
          setPendingStairs({ type: 'up', x, y });
        }
        break;
        
      case TILE_TYPES.STAIRS_DOWN:
        if (currentFloor < FLOORS - 1) {
          setPendingStairs({ type: 'down', x, y });
        }
        break;
        
      case TILE_TYPES.TRAP:
        setPendingTrap({ x, y });
        break;
        
      case TILE_TYPES.POTION:
        // íšŒë³µ ì¹´ë“œ íšë“
        setCards(prev => ({ ...prev, heal: prev.heal + 1 }));
        addFloatingText('íšŒë³µ ì¹´ë“œ íšë“!', 'text-green-400');
        break;
    }
  };

  const useStairs = () => {
    if (!pendingStairs) return;
    
    if (pendingStairs.type === 'up' && currentFloor > 0) {
      setCurrentFloor(prev => prev - 1);
      // ì˜¬ë¼ê°€ëŠ” ê³„ë‹¨ì˜ ëŒ€ì‘ ê³„ë‹¨ ì°¾ê¸°
      const upperFloor = floors[currentFloor - 1];
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          if (upperFloor[y][x] === TILE_TYPES.STAIRS_DOWN) {
            setPlayerPos({ x, y });
            break;
          }
        }
      }
    } else if (pendingStairs.type === 'down' && currentFloor < FLOORS - 1) {
      const currentPos = { x: pendingStairs.x, y: pendingStairs.y };
      setCurrentFloor(prev => prev + 1);
      
      // ë‚´ë ¤ê°„ ìœ„ì¹˜ì— ì˜¬ë¼ê°€ê¸° ê³„ë‹¨ ìƒì„±
      const newFloors = [...floors];
      newFloors[currentFloor + 1][currentPos.y][currentPos.x] = TILE_TYPES.STAIRS_UP;
      setFloors(newFloors);
      
      // í”Œë ˆì´ì–´ë„ ê°™ì€ ìœ„ì¹˜ë¡œ ì´ë™
      setPlayerPos(currentPos);
    }
    
    setPendingStairs(null);
  };

  const useMultiplierCard = () => {
    if (cards.multiplier_card > 0) {
      setCards(prev => ({ ...prev, multiplier_card: prev.multiplier_card - 1 }));
      setMultiplier(prev => prev + 1.0);
      addFloatingText(`ë°°ìˆ˜ ì¦ê°€! Ã—${multiplier + 1.0}`, 'text-green-400');
    }
  };

  const useTrapDisarm = () => {
    if (cards.trap_disarm > 0 && pendingTrap) {
      setCards(prev => ({ ...prev, trap_disarm: prev.trap_disarm - 1 }));
      // í•´ì œëœ í•¨ì • ëª©ë¡ì— ì¶”ê°€
      setDisarmedTraps(prev => [...prev, `${currentFloor},${pendingTrap.x},${pendingTrap.y}`]);
      // í•¨ì •í•´ì œ ì¹´ë“œë¥¼ ì¨ë„ ê°•ì œ ë°ë¯¸ì§€
      setHealth(prev => {
        const newHealth = prev - 1;
        if (newHealth <= 0) {
          setGameOverReason('death');
          setGameState('gameOver');
          return 0;
        }
        return newHealth;
      });
      setMultiplier(1); // ë°°ìˆ˜ ì´ˆê¸°í™”
      addFloatingText('-1 ì²´ë ¥', 'text-red-400');
      addFloatingText('ë°°ìˆ˜ ì´ˆê¸°í™”!', 'text-red-400');
      setPendingTrap(null);
    }
  };

  const takeTrapDamage = () => {
    setHealth(prev => {
      const newHealth = prev - 1;
      if (newHealth <= 0) {
        setGameOverReason('death');
        setGameState('gameOver');
        return 0;
      }
      return newHealth;
    });
    setMultiplier(1); // ë°°ìˆ˜ ì´ˆê¸°í™”
    addFloatingText('-1 ì²´ë ¥', 'text-red-400');
    addFloatingText('ë°°ìˆ˜ ì´ˆê¸°í™”!', 'text-red-400');
    setPendingTrap(null);
  };

  const useHeal = () => {
    if (cards.heal > 0 && health < 3) {
      setCards(prev => ({ ...prev, heal: prev.heal - 1 }));
      setHealth(prev => Math.min(prev + 1, 3));
      addFloatingText('+1 ì²´ë ¥', 'text-green-400');
    }
  };

  const useMap = () => {
    if (cards.map > 0) {
      setCards(prev => ({ ...prev, map: prev.map - 1 }));
      
      // ì£¼ë³€ 3x3 ì˜ì—­ ê³µê°œ
      const newMapRevealed = [...mapRevealed];
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const x = playerPos.x + dx;
          const y = playerPos.y + dy;
          if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
            newMapRevealed.push(`${currentFloor},${x},${y}`);
          }
        }
      }
      setMapRevealed(newMapRevealed);
      addFloatingText('ì§€ë„ ì‚¬ìš©!', 'text-purple-400');
    }
  };

  const checkEscape = () => {
    if (playerPos.x === entrancePos.x && playerPos.y === entrancePos.y && currentFloor === 0) {
      setPendingEscape(true);
    }
  };

  const confirmEscape = () => {
    const target = DIFFICULTIES[difficulty].target;
    setGameOverReason('escape');
    
    if (score >= target) {
      setGameState('victory');
    } else {
      setGameState('gameOver');
    }
    setPendingEscape(false);
  };

  const getTileDisplay = (x, y) => {
    const isRevealed = revealed[currentFloor][y][x];
    const isPlayer = playerPos.x === x && playerPos.y === y;
    const isMapRevealed = mapRevealed.includes(`${currentFloor},${x},${y}`) && !isRevealed;
    const isEntrance = x === entrancePos.x && y === entrancePos.y && currentFloor === 0;
    const isDisarmedTrap = disarmedTraps.includes(`${currentFloor},${x},${y}`);
    
    if (isPlayer) {
      return <div className="w-6 h-6 bg-blue-500 rounded-full border-2 border-white"></div>;
    }
    
    if (!isRevealed && !isMapRevealed) {
      return <div className="w-full h-full bg-gray-600"></div>;
    }
    
    if (isMapRevealed) {
      const tileType = floors[currentFloor][y][x];
      let bgColor = 'bg-gray-400';
      let icon = null;
      
      switch (tileType) {
        case TILE_TYPES.TRAP:
          if (isDisarmedTrap) {
            bgColor = 'bg-gray-400';
            icon = null; // ì£¼ì˜ í‘œì‹œ ìˆ¨ê¹€
          } else {
            bgColor = 'bg-red-300';
            icon = <span className="text-red-600 text-xs">âš </span>;
          }
          break;
        case TILE_TYPES.TREASURE:
          bgColor = 'bg-yellow-300';
          icon = <Gem className="w-3 h-3 text-yellow-600" />;
          break;
        case TILE_TYPES.BIG_TREASURE:
          bgColor = 'bg-orange-300';
          icon = <Gem className="w-4 h-4 text-orange-600" />;
          break;
        case TILE_TYPES.FINAL_TREASURE:
          bgColor = 'bg-purple-300';
          icon = <Gem className="w-5 h-5 text-purple-600" />;
          break;
        case TILE_TYPES.MULTIPLIER:
          bgColor = 'bg-purple-300';
          icon = <span className="text-purple-600 text-xs">Ã—</span>;
          break;
        case TILE_TYPES.CARD:
          bgColor = 'bg-blue-300';
          icon = <span className="text-blue-600 text-xs">ğŸ“„</span>;
          break;
        case TILE_TYPES.STAIRS_UP:
          bgColor = 'bg-green-300';
          icon = <ChevronUp className="w-3 h-3 text-green-600" />;
          break;
        case TILE_TYPES.STAIRS_DOWN:
          bgColor = 'bg-green-300';
          icon = <ChevronDown className="w-3 h-3 text-green-600" />;
          break;
        case TILE_TYPES.WALL:
          bgColor = 'bg-gray-600';
          icon = <span className="text-gray-800 text-xs">â– </span>;
          break;
        case TILE_TYPES.POTION:
          bgColor = 'bg-pink-300';
          icon = <Heart className="w-3 h-3 text-pink-600" />;
          break;
        default:
          break;
      }
      
      return <div className={`w-full h-full ${bgColor} flex items-center justify-center opacity-70`}>{icon}</div>;
    }
    
    if (isEntrance && isRevealed) {
      return <div className="w-full h-full bg-green-500 flex items-center justify-center">
        <Home className="w-4 h-4 text-white" />
      </div>;
    }
    
    const tileType = floors[currentFloor][y][x];
    let bgColor = 'bg-gray-300';
    let icon = null;
    
    switch (tileType) {
      case TILE_TYPES.EMPTY:
        bgColor = 'bg-gray-300';
        break;
      case TILE_TYPES.ENTRANCE:
        bgColor = 'bg-green-500';
        icon = <Home className="w-4 h-4 text-white" />;
        break;
      case TILE_TYPES.TRAP:
        if (isDisarmedTrap) {
          bgColor = 'bg-gray-300';
          icon = null; // ì£¼ì˜ í‘œì‹œ ìˆ¨ê¹€
        } else {
          bgColor = 'bg-red-500';
          icon = <span className="text-white text-sm">âš </span>;
        }
        break;
      case TILE_TYPES.TREASURE:
        bgColor = 'bg-yellow-500';
        icon = <Gem className="w-4 h-4 text-white" />;
        break;
      case TILE_TYPES.BIG_TREASURE:
        bgColor = 'bg-orange-500';
        icon = <Gem className="w-5 h-5 text-white" />;
        break;
      case TILE_TYPES.FINAL_TREASURE:
        bgColor = 'bg-purple-600';
        icon = <Gem className="w-6 h-6 text-white" />;
        break;
      case TILE_TYPES.MULTIPLIER:
        bgColor = 'bg-purple-500';
        icon = <span className="text-white font-bold">Ã—</span>;
        break;
      case TILE_TYPES.CARD:
        bgColor = 'bg-blue-500';
        icon = <span className="text-white">ğŸ“„</span>;
        break;
      case TILE_TYPES.STAIRS_UP:
        bgColor = 'bg-green-600';
        icon = <ChevronUp className="w-4 h-4 text-white" />;
        break;
      case TILE_TYPES.STAIRS_DOWN:
        bgColor = 'bg-green-600';
        icon = <ChevronDown className="w-4 h-4 text-white" />;
        break;
      case TILE_TYPES.WALL:
        bgColor = 'bg-gray-800';
        icon = <span className="text-gray-600 font-bold">â– </span>;
        break;
      case TILE_TYPES.POTION:
        bgColor = 'bg-pink-500';
        icon = <Heart className="w-4 h-4 text-white" />;
        break;
      default:
        break;
    }
    
    return <div className={`w-full h-full ${bgColor} flex items-center justify-center`}>{icon}</div>;
  };

  // ì¹´ë“œ ì»´í¬ë„ŒíŠ¸
  const CardComponent = ({ type, count, onClick, disabled }) => {
    const getCardInfo = () => {
      switch (type) {
        case 'heal':
          return { name: 'íšŒë³µ', icon: Heart, color: 'bg-red-500', hotkey: '1' };
        case 'trap_disarm':
          return { name: 'í•¨ì •í•´ì œ', icon: Shield, color: 'bg-blue-500', hotkey: '2' };
        case 'map':
          return { name: 'ì§€ë„', icon: Map, color: 'bg-purple-500', hotkey: '3' };
        case 'multiplier_card':
          return { name: 'ë°°ìˆ˜ì¦ê°€', icon: () => <span className="text-white font-bold">Ã—+</span>, color: 'bg-green-500', hotkey: '4' };
        default:
          return { name: 'ì¹´ë“œ', icon: Eye, color: 'bg-gray-500', hotkey: '' };
      }
    };

    const { name, icon: IconComponent, color, hotkey } = getCardInfo();

    return (
      <div 
        className={`relative p-3 rounded-lg border-2 cursor-pointer transition-all ${
          disabled 
            ? 'bg-gray-700 border-gray-600 opacity-50 cursor-not-allowed' 
            : `${color} border-white hover:scale-105 hover:shadow-lg`
        }`}
        onClick={!disabled ? onClick : undefined}
      >
        {/* ì¹´ë“œ ìƒë‹¨ */}
        <div className="flex items-center justify-between mb-2">
          {typeof IconComponent === 'function' ? <IconComponent /> : <IconComponent className="w-5 h-5 text-white" />}
          <span className="text-white font-bold text-lg">{count}</span>
        </div>
        
        {/* ì¹´ë“œ í•˜ë‹¨ */}
        <div className="text-center">
          <div className="text-white font-semibold text-sm">{name}</div>
          <div className="text-white text-xs opacity-75">[{hotkey}]</div>
        </div>
        
        {/* ì¹´ë“œ í…Œë‘ë¦¬ íš¨ê³¼ */}
        <div className="absolute inset-0 rounded-lg border border-white opacity-20"></div>
      </div>
    );
  };

  // í‚¤ë³´ë“œ ì…ë ¥ ì²˜ë¦¬
  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameState !== 'playing') return;
      
      switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          movePlayer(0, -1);
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          movePlayer(0, 1);
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          movePlayer(-1, 0);
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          movePlayer(1, 0);
          break;
        case '1':
          useHeal();
          break;
        case '2':
          useTrapDisarm();
          break;
        case '3':
          useMap();
          break;
        case '4':
          useMultiplierCard();
          break;
        case 'r':
          if (playerPos.x === entrancePos.x && playerPos.y === entrancePos.y && currentFloor === 0) {
            setPendingEscape(true);
          }
          break;
        case 'Enter':
        case ' ':
          if (pendingStairs) useStairs();
          else if (pendingEscape) confirmEscape();
          break;
        default:
          break;
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState, playerPos, cards, health, currentFloor, pendingStairs]);

  if (gameState === 'menu') {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white p-8">
        <h1 className="text-4xl font-bold mb-8 text-yellow-400">LOOT1004 ë¦¬ë©”ì´í¬</h1>
        <div className="mb-8">
          <h2 className="text-xl mb-4">ë‚œì´ë„ ì„ íƒ:</h2>
          {Object.entries(DIFFICULTIES).map(([key, diff]) => (
            <div key={key} className="mb-2">
              <button
                onClick={() => setDifficulty(key)}
                className={`px-4 py-2 rounded mr-4 ${
                  difficulty === key ? 'bg-yellow-600' : 'bg-gray-700 hover:bg-gray-600'
                }`}
              >
                {diff.name}
              </button>
              <span>ëª©í‘œ: {diff.target.toLocaleString()}ì </span>
            </div>
          ))}
        </div>
        <button
          onClick={initializeGame}
          className="px-6 py-3 bg-green-600 hover:bg-green-700 rounded text-xl font-bold"
        >
          ê²Œì„ ì‹œì‘
        </button>
        <div className="mt-8 text-sm text-gray-400 max-w-md text-center">
          <h3 className="font-bold mb-2 text-white">ì¡°ì‘ë²•</h3>
          <p>â€¢ WASD / í™”ì‚´í‘œí‚¤ë¡œ ì´ë™</p>
          <p>â€¢ 1/2/3/4: ì¹´ë“œ ì‚¬ìš©</p>
          <p>â€¢ R: ì…êµ¬ì—ì„œ íƒˆì¶œ</p>
          <p>â€¢ Enter/Space: ê³„ë‹¨/íƒˆì¶œ í™•ì¸</p>
          <div className="mt-4 border-t border-gray-600 pt-4">
            <p>â€¢ 3ì¸µ ë˜ì „ì„ íƒí—˜í•˜ê³  ì…êµ¬ë¡œ ëŒì•„ì˜¤ì„¸ìš”</p>
            <p>â€¢ í•¨ì •ì„ ë°Ÿìœ¼ë©´ ë¬´ì¡°ê±´ ë°ë¯¸ì§€ë¥¼ ë°›ìŠµë‹ˆë‹¤</p>
            <p>â€¢ ë°ë¯¸ì§€ë¥¼ ë°›ìœ¼ë©´ ë°°ìˆ˜ê°€ 1ë¡œ ì´ˆê¸°í™”ë©ë‹ˆë‹¤</p>
            <p>â€¢ ì²´ë ¥ì´ 0ì´ ë˜ë©´ ê²Œì„ì˜¤ë²„</p>
          </div>
        </div>
      </div>
    );
  }

  if (gameState === 'gameOver') {
    if (gameOverReason === 'death') {
      return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white">
          <h1 className="text-4xl font-bold mb-4 text-red-500">ê²Œì„ ì˜¤ë²„</h1>
          <p className="text-xl mb-2 text-red-400">ìµœì¢… ì ìˆ˜: 0ì  (íƒˆì¶œ ì‹¤íŒ¨)</p>
          <p className="text-lg mb-2 text-red-400">íšë“ ê¸ˆì•¡: 0ì›</p>
          <p className="text-lg mb-8">ëª©í‘œ: {DIFFICULTIES[difficulty].target.toLocaleString()}ì </p>
          <button
            onClick={() => setGameState('menu')}
            className="px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded"
          >
            ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
          </button>
        </div>
      );
    } else {
      // íƒˆì¶œ ì„±ê³µí–ˆì§€ë§Œ ëª©í‘œ ì ìˆ˜ ë¯¸ë‹¬
      const money = Math.floor(score * 0.1);
      return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white">
          <h1 className="text-4xl font-bold mb-4 text-yellow-500">íƒˆì¶œ ì„±ê³µ!</h1>
          <p className="text-xl mb-2">ìµœì¢… ì ìˆ˜: {score.toLocaleString()}ì </p>
          <p className="text-lg mb-2 text-green-400">íšë“ ê¸ˆì•¡: {money.toLocaleString()}ì›</p>
          <p className="text-lg mb-4 text-red-400">ëª©í‘œ ë¯¸ë‹¬: {DIFFICULTIES[difficulty].target.toLocaleString()}ì </p>
          <p className="text-sm mb-8 text-gray-400">ëª©í‘œ ì ìˆ˜ë¥¼ ë‹¬ì„±í•´ì•¼ ì™„ì „í•œ ìŠ¹ë¦¬ì…ë‹ˆë‹¤!</p>
          <button
            onClick={() => setGameState('menu')}
            className="px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded"
          >
            ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
          </button>
        </div>
      );
    }
  }

  if (gameState === 'victory') {
    const money = Math.floor(score * 0.1);
    return (
      <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white">
        <h1 className="text-4xl font-bold mb-4 text-green-500">ìŠ¹ë¦¬!</h1>
        <p className="text-xl mb-2">ìµœì¢… ì ìˆ˜: {score.toLocaleString()}ì </p>
        <p className="text-lg mb-2 text-green-400">íšë“ ê¸ˆì•¡: {money.toLocaleString()}ì›</p>
        <p className="text-lg mb-8">ëª©í‘œ ë‹¬ì„±: {DIFFICULTIES[difficulty].target.toLocaleString()}ì </p>
        <button
          onClick={() => setGameState('menu')}
          className="px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded"
        >
          ë©”ë‰´ë¡œ ëŒì•„ê°€ê¸°
        </button>
      </div>
    );
  }

  if (floors.length === 0) return <div>ë¡œë”© ì¤‘...</div>;

  return (
    <div className="min-h-screen bg-gray-900 text-white p-4">
      <style jsx>{`
        @keyframes fadeUp {
          0% {
            opacity: 1;
            transform: translate(-50%, 0px);
          }
          100% {
            opacity: 0;
            transform: translate(-50%, -50px);
          }
        }
      `}</style>
      
      {/* ìƒë‹¨ ë°°ìˆ˜ í‘œì‹œ ì œê±° */}
      
      {/* í•¨ì • ëŒ€í™”ìƒì */}
      {pendingTrap && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded border-2 border-red-500">
            <h3 className="text-xl font-bold text-red-500 mb-4">í•¨ì • ë°œê²¬!</h3>
            <p className="mb-4">ì–´ë–¤ ì„ íƒì„ í•˜ë“  1ì˜ ë°ë¯¸ì§€ë¥¼ ë°›ìŠµë‹ˆë‹¤!</p>
            <div className="flex space-x-4">
              <button
                onClick={useTrapDisarm}
                disabled={cards.trap_disarm === 0}
                className={`px-4 py-2 rounded ${
                  cards.trap_disarm > 0 
                    ? 'bg-green-600 hover:bg-green-700' 
                    : 'bg-gray-600 cursor-not-allowed'
                }`}
              >
                í•´ì œ ì¹´ë“œ ì‚¬ìš© ({cards.trap_disarm})
              </button>
              <button
                onClick={takeTrapDamage}
                className="px-4 py-2 bg-red-600 hover:bg-red-700 rounded"
              >
                ê·¸ëƒ¥ ë°›ê¸°
              </button>
            </div>
          </div>
        </div>
      )}

      {/* íƒˆì¶œ í™•ì¸ ëŒ€í™”ìƒì */}
      {pendingEscape && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded border-2 border-yellow-500">
            <h3 className="text-xl font-bold text-yellow-500 mb-4">ì…êµ¬ ë°œê²¬!</h3>
            <div className="mb-4">
              <p>íƒˆì¶œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?</p>
              <p className="text-sm mt-2">í˜„ì¬ ì ìˆ˜: {score.toLocaleString()}ì </p>
              <p className="text-green-400 text-sm">íšë“ ê¸ˆì•¡: {Math.floor(score * 0.1).toLocaleString()}ì›</p>
            </div>
            <div className="flex space-x-4">
              <button
                onClick={confirmEscape}
                className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded"
              >
                íƒˆì¶œí•˜ê¸° [Enter/Space]
              </button>
              <button
                onClick={() => setPendingEscape(false)}
                className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded"
              >
                ê³„ì† íƒí—˜
              </button>
            </div>
          </div>
        </div>
      )}

      {/* ê³„ë‹¨ ëŒ€í™”ìƒì */}
      {pendingStairs && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded border-2 border-green-500">
            <h3 className="text-xl font-bold text-green-500 mb-4">ê³„ë‹¨ ë°œê²¬!</h3>
            <p className="mb-4">
              {pendingStairs.type === 'up' 
                ? `${currentFloor}ì¸µìœ¼ë¡œ ì˜¬ë¼ê°€ì‹œê² ìŠµë‹ˆê¹Œ?` 
                : `${currentFloor + 2}ì¸µìœ¼ë¡œ ë‚´ë ¤ê°€ì‹œê² ìŠµë‹ˆê¹Œ?`}
            </p>
            <div className="flex space-x-4">
              <button
                onClick={useStairs}
                className="px-4 py-2 bg-green-600 hover:bg-green-700 rounded"
              >
                {pendingStairs.type === 'up' ? 'ì˜¬ë¼ê°€ê¸°' : 'ë‚´ë ¤ê°€ê¸°'} [Enter/Space]
              </button>
              <button
                onClick={() => setPendingStairs(null)}
                className="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded"
              >
                ì·¨ì†Œ
              </button>
            </div>
          </div>
        </div>
      )}

      {/* í”Œë¡œíŒ… í…ìŠ¤íŠ¸ ì œê±° */}

      <div className="flex gap-4">
        {/* ì™¼ìª½: ê²Œì„ ë³´ë“œì™€ ì¹´ë“œ */}
        <div className="flex gap-4">
          {/* ê²Œì„ ë³´ë“œ */}
          <div className="flex-1">
            <div className="mb-4 flex items-center justify-center gap-4">
              <h2 className="text-2xl font-bold text-yellow-400">{currentFloor + 1}ì¸µ</h2>
              <div className="bg-purple-600 px-4 py-1 rounded-lg border-2 border-purple-400">
                <span className="text-lg font-bold text-white">ë°°ìˆ˜: Ã—{multiplier}</span>
              </div>
              {/* íƒˆì¶œ ë²„íŠ¼ */}
              {playerPos.x === entrancePos.x && playerPos.y === entrancePos.y && currentFloor === 0 && (
                <button
                  onClick={() => setPendingEscape(true)}
                  className="px-3 py-1 bg-yellow-600 hover:bg-yellow-700 rounded flex items-center text-sm"
                >
                  <Home className="w-4 h-4 mr-1" />
                  íƒˆì¶œ [R]
                </button>
              )}
            </div>
            <div className="grid grid-cols-7 gap-1 bg-gray-700 p-4 rounded max-w-md mx-auto">
              {floors[currentFloor].map((row, y) =>
                row.map((_, x) => (
                  <div
                    key={`${x}-${y}`}
                    className="w-10 h-10 border border-gray-500 flex items-center justify-center"
                  >
                    {getTileDisplay(x, y)}
                  </div>
                ))
              )}
            </div>
            
            {/* ìƒíƒœì°½ - ë§µ í•˜ë‹¨ */}
            <div className="bg-gray-800 p-4 rounded mt-4 max-w-md mx-auto">
              <div className="flex items-center justify-between mb-2">
                <h3 className="text-lg font-bold">ìƒíƒœ</h3>
                <div className="text-sm">
                  <span className="text-gray-400">íšë“ì •ë³´: </span>
                  <span className="text-yellow-400">
                    {floatingTexts.length > 0 ? floatingTexts[floatingTexts.length - 1].text : 'ì—†ìŒ'}
                  </span>
                </div>
              </div>
              <div className="grid grid-cols-2 gap-4">
                {/* ì™¼ìª½: ì²´ë ¥, ì ìˆ˜, ë°°ìˆ˜ */}
                <div className="space-y-2">
                  <div className="flex items-center">
                    <Heart className="w-5 h-5 text-red-500 mr-2" />
                    <span>ì²´ë ¥: {health}/3</span>
                  </div>
                  <div>ì ìˆ˜: {score.toLocaleString()}</div>
                  <div className="text-yellow-400">ë°°ìˆ˜: Ã—{multiplier}</div>
                </div>
                
                {/* ì˜¤ë¥¸ìª½: ì¸µ, ëª©í‘œ */}
                <div className="space-y-2">
                  <div>ì¸µ: {currentFloor + 1}/3</div>
                  <div>ëª©í‘œ: {DIFFICULTIES[difficulty].target.toLocaleString()}</div>
                </div>
              </div>
            </div>
          </div>

          {/* ì¹´ë“œì°½ - ë§µ ì˜¤ë¥¸ìª½ì— ë°”ë¡œ ë¶™ì—¬ì„œ ë°°ì¹˜ */}
          <div className="w-40 space-y-3">
            <h3 className="text-lg font-bold text-center text-white">ì¹´ë“œ</h3>
            <CardComponent 
              type="heal" 
              count={cards.heal}
              onClick={useHeal}
              disabled={cards.heal === 0 || health === 3}
            />
            <CardComponent 
              type="trap_disarm" 
              count={cards.trap_disarm}
              onClick={useTrapDisarm}
              disabled={cards.trap_disarm === 0 || !pendingTrap}
            />
            <CardComponent 
              type="map" 
              count={cards.map}
              onClick={useMap}
              disabled={cards.map === 0}
            />
            <CardComponent 
              type="multiplier_card" 
              count={cards.multiplier_card}
              onClick={useMultiplierCard}
              disabled={cards.multiplier_card === 0}
            />
          </div>
        </div>

        {/* ì¤‘ê°„: ë¹ˆ ê³µê°„ */}
        <div className="w-20">
        </div>

        {/* ì˜¤ë¥¸ìª½: ë¹ˆ ê³µê°„ (ê¸°ì¡´ ì¹´ë“œ ìë¦¬) */}
        <div className="w-40">
        </div>
      </div>
    </div>
  );
}

export default Loot1004Game;
