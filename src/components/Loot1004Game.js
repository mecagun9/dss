import React, { useState, useEffect, useCallback } from 'react';

const GRID_SIZE = 7;
const FLOORS = 3;
const DIFFICULTIES = {
  easy: { target: 5000, name: 'Ïâ¨ÏõÄ' },
  normal: { target: 10000, name: 'Î≥¥ÌÜµ' },
  hard: { target: 20000, name: 'Ïñ¥Î†§ÏõÄ' }
};

const CARD_TYPES = {
  HEAL: 'heal',
  TRAP_DISARM: 'trap_disarm', 
  MAP: 'map',
  SCORE: 'score',
  MULTIPLIER: 'multiplier_card'
};

const TILE_TYPES = {
  EMPTY: 'empty',
  TREASURE: 'treasure',
  TRAP: 'trap',
  BIG_TREASURE: 'big_treasure',
  MULTIPLIER: 'multiplier',
  CARD: 'card',
  STAIRS_UP: 'stairs_up',
  STAIRS_DOWN: 'stairs_down',
  ENTRANCE: 'entrance',
  FINAL_TREASURE: 'final_treasure',
  WALL: 'wall',
  POTION: 'potion'
};

// ÏïÑÏù¥ÌÖú Ï†ïÎ≥¥ ÏÉÅÏàò
const ITEM_INFO = {
  [TILE_TYPES.TREASURE]: { icon: 'üíé', points: [50, 150], message: 'Î≥¥Î¨º Î∞úÍ≤¨!' },
  [TILE_TYPES.BIG_TREASURE]: { icon: 'üíç', points: [200, 700], message: 'ÎåÄÎ≥¥Î¨º Î∞úÍ≤¨!' },
  [TILE_TYPES.FINAL_TREASURE]: { icon: 'üëë', points: [500, 1500], message: 'ÏµúÏ¢Ö Î≥¥Î¨º!' },
  [TILE_TYPES.MULTIPLIER]: { icon: '‚≠ê', points: [0, 0], message: 'Î∞∞Ïàò Ï¶ùÍ∞Ä! +0.5' },
  [TILE_TYPES.CARD]: { icon: 'üÉè', points: [0, 0], message: 'Ïπ¥Îìú ÌöçÎìù!' },
  [TILE_TYPES.POTION]: { icon: 'üß™', points: [0, 0], message: 'Ï≤¥Î†• ÌöåÎ≥µ! +1' }
};

function Loot1004Game() {
  const [difficulty, setDifficulty] = useState('normal');
  const [gameState, setGameState] = useState('menu');
  const [floors, setFloors] = useState([]);
  const [revealed, setRevealed] = useState([]);
  const [currentFloor, setCurrentFloor] = useState(0);
  const [playerPos, setPlayerPos] = useState({ x: 3, y: 6 });
  const [entrancePos, setEntrancePos] = useState({ x: 3, y: 6 });
  const [health, setHealth] = useState(3);
  const [score, setScore] = useState(0);
  const [multiplier, setMultiplier] = useState(1);
  const [cards, setCards] = useState({ heal: 2, trap_disarm: 3, map: 2, multiplier_card: 1 });
  const [pendingTrap, setPendingTrap] = useState(null);
  const [mapRevealed, setMapRevealed] = useState([]);
  const [floatingTexts, setFloatingTexts] = useState([]);
  const [gameOverReason, setGameOverReason] = useState('death');
  const [disarmedTraps, setDisarmedTraps] = useState([]);
  const [wasAtEntrance, setWasAtEntrance] = useState(false);
  const [itemIcons, setItemIcons] = useState([]);
  const [showModal, setShowModal] = useState(false);
  const [modalConfig, setModalConfig] = useState({ title: '', message: '', onConfirm: null, onCancel: null });
  const [blockedTiles, setBlockedTiles] = useState([]); // Í∞à Ïàò ÏóÜÎäî Ïπ∏Îì§
  const [isMapEditor, setIsMapEditor] = useState(false); // Îßµ ÏóêÎîîÌÑ∞ Î™®Îìú
  const [selectedTile, setSelectedTile] = useState(null); // ÏÑ†ÌÉùÎêú ÌÉÄÏùº

  // Í≥µÌÜµ Ìï®Ïàò: ÏïÑÏù¥ÌÖú Ï†úÍ±∞ Î∞è ÏïÑÏù¥ÏΩò ÏóÖÎç∞Ïù¥Ìä∏
  const removeItemAndUpdateIcons = useCallback((x, y) => {
    floors[currentFloor][y][x] = TILE_TYPES.EMPTY;
    setItemIcons(prev => {
      const newIcons = [...prev];
      if (newIcons[currentFloor] && newIcons[currentFloor][y]) {
        newIcons[currentFloor][y][x] = null;
      }
      return newIcons;
    });
  }, [currentFloor, floors]);

  // Í≥µÌÜµ Ìï®Ïàò: Ï†êÏàò ÌöçÎìù ÏïÑÏù¥ÌÖú Ï≤òÎ¶¨
  const handleScoreItem = useCallback((tileType, x, y) => {
    const itemInfo = ITEM_INFO[tileType];
    if (itemInfo.points[0] > 0) {
      const points = Math.floor(Math.random() * (itemInfo.points[1] - itemInfo.points[0])) + itemInfo.points[0];
      const totalPoints = points * multiplier;
      setScore(prev => prev + totalPoints);
      addFloatingText(`${itemInfo.message} +${totalPoints}Ï†ê`);
    } else {
      addFloatingText(itemInfo.message);
    }
    removeItemAndUpdateIcons(x, y);
  }, [multiplier, removeItemAndUpdateIcons]);

  // Í≥µÌÜµ Ìï®Ïàò: ÌäπÏàò ÏïÑÏù¥ÌÖú Ï≤òÎ¶¨
  const handleSpecialItem = useCallback((tileType, x, y) => {
    switch (tileType) {
      case TILE_TYPES.MULTIPLIER:
        setMultiplier(prev => prev + 0.5);
        break;
      case TILE_TYPES.CARD:
        const cardType = Object.values(CARD_TYPES)[Math.floor(Math.random() * Object.values(CARD_TYPES).length)];
        setCards(prev => ({ ...prev, [cardType]: prev[cardType] + 1 }));
        break;
      case TILE_TYPES.POTION:
        setHealth(prev => Math.min(3, prev + 1));
        break;
    }
    addFloatingText(ITEM_INFO[tileType].message);
    removeItemAndUpdateIcons(x, y);
  }, [removeItemAndUpdateIcons]);

  const initializeGame = useCallback(() => {
    // ÏûÖÍµ¨ ÏúÑÏπò ÎûúÎç§ ÏÑ†ÌÉù
    const edges = [
      { x: 0, y: 3 }, { x: 6, y: 3 },
      { x: 3, y: 0 }, { x: 3, y: 6 }
    ];
    const entrance = edges[Math.floor(Math.random() * edges.length)];
    setEntrancePos(entrance);

    // 3Í∞ú Ï∏µ Ï¥àÍ∏∞Ìôî
    const newFloors = [];
    const newRevealed = [];
    const newItemIcons = [];
    
    // Í≥ÑÎã® Ï¢åÌëú Í≥†Ï†ï
    const stairsDownPos = { x: 5, y: 5 };
    const stairsUpPos = { x: 1, y: 1 };
    
    for (let floor = 0; floor < FLOORS; floor++) {
      const grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
      const revealedGrid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(false));
      const floorIcons = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
      
      // Í≥ÑÎã® Î∞∞Ïπò
      if (floor === 0) {
        grid[entrance.y][entrance.x] = TILE_TYPES.ENTRANCE;
        revealedGrid[entrance.y][entrance.x] = true;
        grid[stairsDownPos.y][stairsDownPos.x] = TILE_TYPES.STAIRS_DOWN;
      } else if (floor === 1) {
        grid[stairsUpPos.y][stairsUpPos.x] = TILE_TYPES.STAIRS_UP;
        grid[stairsDownPos.y][stairsDownPos.x] = TILE_TYPES.STAIRS_DOWN;
      } else if (floor === 2) {
        grid[stairsUpPos.y][stairsUpPos.x] = TILE_TYPES.STAIRS_UP;
        
        // ÏµúÏ¢Ö Î≥¥Î¨º Î∞∞Ïπò
        let finalTreasurePlaced = false;
        while (!finalTreasurePlaced) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          if (grid[y][x] === null && (x !== stairsUpPos.x || y !== stairsUpPos.y)) {
            grid[y][x] = TILE_TYPES.FINAL_TREASURE;
            finalTreasurePlaced = true;
          }
        }
      }
      
      // ÏïÑÏù¥ÌÖú ÎûúÎç§ Î∞∞Ïπò
      const itemCount = Math.floor(Math.random() * 8) + 12;
      for (let i = 0; i < itemCount; i++) {
        let placed = false;
        while (!placed) {
          const x = Math.floor(Math.random() * GRID_SIZE);
          const y = Math.floor(Math.random() * GRID_SIZE);
          
          if (grid[y][x] === null) {
            const rand = Math.random();
            let tileType;
            if (rand < 0.3) tileType = TILE_TYPES.TREASURE;
            else if (rand < 0.5) tileType = TILE_TYPES.TRAP;
            else if (rand < 0.6) tileType = TILE_TYPES.BIG_TREASURE;
            else if (rand < 0.7) tileType = TILE_TYPES.MULTIPLIER;
            else if (rand < 0.8) tileType = TILE_TYPES.CARD;
            else if (rand < 0.9) tileType = TILE_TYPES.POTION;
            else tileType = TILE_TYPES.WALL;
            
            grid[y][x] = tileType;
            
            // ÏïÑÏù¥ÏΩò ÏÑ§Ï†ï
            if (tileType !== TILE_TYPES.WALL && tileType !== TILE_TYPES.EMPTY && 
                tileType !== TILE_TYPES.ENTRANCE && tileType !== TILE_TYPES.STAIRS_UP && 
                tileType !== TILE_TYPES.STAIRS_DOWN) {
              floorIcons[y][x] = { x, y, type: tileType };
            }
            placed = true;
          }
        }
      }
      
      newFloors.push(grid);
      newRevealed.push(revealedGrid);
      newItemIcons.push(floorIcons);
    }
    
    // ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    setFloors(newFloors);
    setRevealed(newRevealed);
    setItemIcons(newItemIcons);
    setCurrentFloor(0);
    setPlayerPos({ x: entrance.x, y: entrance.y });
    setHealth(3);
    setScore(0);
    setMultiplier(1);
    setCards({ heal: 2, trap_disarm: 3, map: 2, multiplier_card: 1 });
    setDisarmedTraps([]);
    setMapRevealed([]);
    setFloatingTexts([]);
    setPendingTrap(null);
    setWasAtEntrance(false);
    setBlockedTiles([]);
    setIsMapEditor(false);
    setSelectedTile(null);
    setGameState('playing');
  }, []);

  const addFloatingText = useCallback((text) => {
    const id = Date.now();
    setFloatingTexts(prev => [...prev, { 
      id, text, x: playerPos.x, y: playerPos.y, floor: currentFloor 
    }]);
    
    setTimeout(() => {
      setFloatingTexts(prev => prev.filter(t => t.id !== id));
    }, 3000);
  }, [playerPos, currentFloor]);

  const showConfirmModal = useCallback((title, message, onConfirm, onCancel) => {
    setModalConfig({ title, message, onConfirm, onCancel });
    setShowModal(true);
  }, []);

  const handleModalConfirm = useCallback(() => {
    if (modalConfig.onConfirm) modalConfig.onConfirm();
    setShowModal(false);
  }, [modalConfig]);

  const handleModalCancel = useCallback(() => {
    if (modalConfig.onCancel) modalConfig.onCancel();
    setShowModal(false);
  }, [modalConfig]);

  // ÏßÄÎèÑ Ïπ¥Îìú ÏÇ¨Ïö©
  const useMap = useCallback(() => {
    if (cards.map <= 0) return;
    
    setCards(prev => ({ ...prev, map: prev.map - 1 }));
    
    // ÌîåÎ†àÏù¥Ïñ¥ Ï£ºÎ≥Ä 8Ïπ∏ÏùÑ ÏßÄÎèÑÎ°ú Í≥µÍ∞ú
    const newMapRevealed = [];
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        if (dx === 0 && dy === 0) continue; // ÌîåÎ†àÏù¥Ïñ¥ ÏúÑÏπò Ï†úÏô∏
        
        const newX = playerPos.x + dx;
        const newY = playerPos.y + dy;
        
        if (newX >= 0 && newX < 7 && newY >= 0 && newY < 7) {
          newMapRevealed.push({ x: newX, y: newY });
          
          // ÏßÄÎèÑÎ°ú Í≥µÍ∞úÎêú Ïπ∏ÏùÑ Î∞©Î¨∏Ìïú Í≤ÉÏ≤òÎüº revealed ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
          setRevealed(prev => {
            const newRevealed = [...prev];
            if (!newRevealed[currentFloor]) {
              newRevealed[currentFloor] = Array(7).fill().map(() => Array(7).fill(false));
            }
            newRevealed[currentFloor][newY][newX] = true;
            return newRevealed;
          });
        }
      }
    }
    
    setMapRevealed(newMapRevealed);
    addFloatingText('ÏßÄÎèÑ Ïπ¥Îìú ÏÇ¨Ïö©!');
  }, [cards.map, playerPos, currentFloor, addFloatingText]);

  // Î†åÎçîÎßÅ Ìï®ÏàòÎì§
  const getTileDisplay = useCallback((tile, x, y) => {
    // Îßµ ÏóêÎîîÌÑ∞ Î™®ÎìúÏù¥Í±∞ÎÇò Í≥µÍ∞úÎêú Ïπ∏Ïù∏ Í≤ΩÏö∞
    if (isMapEditor || (revealed[currentFloor] && revealed[currentFloor][y] && revealed[currentFloor][y][x])) {
      const tileIcons = {
        [TILE_TYPES.EMPTY]: '‚¨ú',
        [TILE_TYPES.TREASURE]: 'üíé',
        [TILE_TYPES.BIG_TREASURE]: 'üíç',
        [TILE_TYPES.TRAP]: 'üí£',
        [TILE_TYPES.MULTIPLIER]: '‚≠ê',
        [TILE_TYPES.CARD]: 'üÉè',
        [TILE_TYPES.STAIRS_UP]: '‚¨ÜÔ∏è',
        [TILE_TYPES.STAIRS_DOWN]: '‚¨áÔ∏è',
        [TILE_TYPES.ENTRANCE]: 'üö™',
        [TILE_TYPES.FINAL_TREASURE]: 'üëë',
        [TILE_TYPES.WALL]: 'üß±',
        [TILE_TYPES.POTION]: 'üß™'
      };
      return tileIcons[tile] || '‚¨ú';
    }
    return '‚¨õ';
  }, [currentFloor, revealed, isMapEditor]);

  // ÏßÄÎÇòÍ∞Ñ Ïπ∏Ïóê ÏïÑÏù¥ÌÖú ÌëúÏãú Ìï®Ïàò
  const getVisitedTileDisplay = useCallback((tile, x, y) => {
    // Îßµ ÏóêÎîîÌÑ∞ Î™®ÎìúÏóêÏÑúÎäî Î™®Îì† ÌÉÄÏùº Í≥µÍ∞ú
    if (isMapEditor) {
      return getTileDisplay(tile, x, y);
    }
    
    // Ïù¥ÎØ∏ Í≥µÍ∞úÎêú Ïπ∏Ïù¥Í±∞ÎÇò ÏßÄÎèÑÎ°ú Í≥µÍ∞úÎêú Ïπ∏Ïù∏ Í≤ΩÏö∞
    if ((revealed[currentFloor] && revealed[currentFloor][y] && revealed[currentFloor][y][x]) || 
        mapRevealed.some(pos => pos.x === x && pos.y === y)) {
      return getTileDisplay(tile, x, y);
    }
    
    // Î∞©Î¨∏ÌïòÏßÄ ÏïäÏùÄ Ïπ∏ÏùÄ ÏôÑÏ†ÑÌûà Í∞ÄÎ¶º
    return '‚¨õ';
  }, [currentFloor, revealed, mapRevealed, getTileDisplay, isMapEditor]);

  const movePlayer = useCallback((dx, dy) => {
    if (gameState !== 'playing') return;
    
    const newPos = { x: playerPos.x + dx, y: playerPos.y + dy };
    
    // Í≤ΩÍ≥Ñ Î∞è Î≤Ω Ï≤¥ÌÅ¨
    if (newPos.x < 0 || newPos.x >= GRID_SIZE || newPos.y < 0 || newPos.y >= GRID_SIZE) {
      // Í∞à Ïàò ÏóÜÎäî Ïπ∏Ïóê X ÌëúÏãú Ï∂îÍ∞Ä
      setBlockedTiles(prev => {
        const key = `${currentFloor},${newPos.x},${newPos.y}`;
        if (!prev.includes(key)) {
          return [...prev, key];
        }
        return prev;
      });
      return;
    }
    
    const tile = floors[currentFloor][newPos.y][newPos.x];
    if (tile === TILE_TYPES.WALL) {
      // Î≤ΩÏóê ÎãøÏïòÏùÑ ÎïåÎèÑ X ÌëúÏãú Ï∂îÍ∞Ä
      setBlockedTiles(prev => {
        const key = `${currentFloor},${newPos.x},${newPos.y}`;
        if (!prev.includes(key)) {
          return [...prev, key];
        }
        return prev;
      });
      return;
    }
    
    // wasAtEntrance ÏÑ§Ï†ï
    if (currentFloor === 0 && playerPos.x === entrancePos.x && playerPos.y === entrancePos.y) {
      if (newPos.x !== entrancePos.x || newPos.y !== entrancePos.y) {
        setWasAtEntrance(true);
      }
    }
    
    // ÏïÑÏù¥ÌÖú ÏÉÅÌò∏ÏûëÏö©
    if (tile === TILE_TYPES.TREASURE || tile === TILE_TYPES.BIG_TREASURE || tile === TILE_TYPES.FINAL_TREASURE) {
      handleScoreItem(tile, newPos.x, newPos.y);
    } else if (tile === TILE_TYPES.MULTIPLIER || tile === TILE_TYPES.CARD || tile === TILE_TYPES.POTION) {
      handleSpecialItem(tile, newPos.x, newPos.y);
    } else if (tile === TILE_TYPES.TRAP) {
      if (disarmedTraps.some(trap => trap.x === newPos.x && trap.y === newPos.y)) {
        removeItemAndUpdateIcons(newPos.x, newPos.y);
      } else {
        showConfirmModal(
          '‚ö†Ô∏è Ìï®Ï†ï Î∞úÍ≤¨!',
          'Ìï®Ï†ïÏùÑ Î∞úÍ≤¨ÌñàÏäµÎãàÎã§!\n\nÌôïÏù∏: Îç∞ÎØ∏ÏßÄÎ•º Î∞õÍ≥† Ìï®Ï†ï Ï†úÍ±∞ Ïπ¥Îìú ÏÇ¨Ïö©\nÏ∑®ÏÜå: Îç∞ÎØ∏ÏßÄÎßå Î∞õÍ∏∞',
          () => {
            if (cards.trap_disarm > 0) {
              setDisarmedTraps(prev => [...prev, { x: newPos.x, y: newPos.y }]);
              setCards(prev => ({ ...prev, trap_disarm: prev.trap_disarm - 1 }));
              addFloatingText('Ìï®Ï†ï Ï†úÍ±∞ Ïπ¥Îìú ÏÇ¨Ïö©!');
              removeItemAndUpdateIcons(newPos.x, newPos.y);
            } else {
              setHealth(prev => prev - 1);
              addFloatingText('Ìï®Ï†ï! Ï≤¥Î†• -1 (Ìï®Ï†ï Ï†úÍ±∞ Ïπ¥Îìú Î∂ÄÏ°±)');
              setPendingTrap({ x: newPos.x, y: newPos.y });
            }
          },
          () => {
            setHealth(prev => prev - 1);
            addFloatingText('Ìï®Ï†ï! Ï≤¥Î†• -1');
            setPendingTrap({ x: newPos.x, y: newPos.y });
          }
        );
        return; // Ìï®Ï†ï Ï≤òÎ¶¨ ÌõÑ Ïù¥ÎèôÌïòÏßÄ ÏïäÏùå
      }
    } else if (tile === TILE_TYPES.STAIRS_DOWN) {
      if (currentFloor < FLOORS - 1) {
        showConfirmModal(
          '‚¨áÔ∏è Í≥ÑÎã® Î∞úÍ≤¨!',
          'Îã§Ïùå Ï∏µÏúºÎ°ú ÎÇ¥Î†§Í∞ÄÏãúÍ≤†ÏäµÎãàÍπå?',
          () => {
            setCurrentFloor(prev => prev + 1);
            setPlayerPos({ x: 3, y: 3 });
            // Ï∏µ Ïù¥Îèô Ïãú ÏãúÏûë Ïπ∏ÏùÑ Î∞©Î¨∏Ìïú Í≤ÉÏúºÎ°ú Ï≤òÎ¶¨
            setRevealed(prev => {
              const newRevealed = [...prev];
              if (!newRevealed[currentFloor + 1]) {
                newRevealed[currentFloor + 1] = Array(7).fill().map(() => Array(7).fill(false));
              }
              newRevealed[currentFloor + 1][3][3] = true;
              return newRevealed;
            });
            addFloatingText('Îã§Ïùå Ï∏µÏúºÎ°ú Ïù¥Îèô');
          },
          () => {}
        );
        return; // Í≥ÑÎã® Ï≤òÎ¶¨ ÌõÑ Ïù¥ÎèôÌïòÏßÄ ÏïäÏùå
      }
    } else if (tile === TILE_TYPES.STAIRS_UP) {
      if (currentFloor > 0) {
        showConfirmModal(
          '‚¨ÜÔ∏è Í≥ÑÎã® Î∞úÍ≤¨!',
          'ÏúÑ Ï∏µÏúºÎ°ú Ïò¨ÎùºÍ∞ÄÏãúÍ≤†ÏäµÎãàÍπå?',
          () => {
            setCurrentFloor(prev => prev - 1);
            setPlayerPos({ x: 3, y: 3 });
            // Ï∏µ Ïù¥Îèô Ïãú ÏãúÏûë Ïπ∏ÏùÑ Î∞©Î¨∏Ìïú Í≤ÉÏúºÎ°ú Ï≤òÎ¶¨
            setRevealed(prev => {
              const newRevealed = [...prev];
              if (!newRevealed[currentFloor - 1]) {
                newRevealed[currentFloor - 1] = Array(7).fill().map(() => Array(7).fill(false));
              }
              newRevealed[currentFloor - 1][3][3] = true;
              return newRevealed;
            });
            addFloatingText('ÏúÑ Ï∏µÏúºÎ°ú Ïù¥Îèô');
          },
          () => {}
        );
        return; // Í≥ÑÎã® Ï≤òÎ¶¨ ÌõÑ Ïù¥ÎèôÌïòÏßÄ ÏïäÏùå
      }
    }
    
    // ÌÉÄÏùº Í≥µÍ∞ú Î∞è ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô
    const newRevealed = [...revealed];
    newRevealed[currentFloor][newPos.y][newPos.x] = true;
    setRevealed(newRevealed);
    setPlayerPos(newPos);
  }, [gameState, playerPos, currentFloor, floors, revealed, disarmedTraps, cards, 
      entrancePos, wasAtEntrance, handleScoreItem, handleSpecialItem, removeItemAndUpdateIcons, 
      showConfirmModal, addFloatingText]);

  // Ïπ¥Îìú ÏÇ¨Ïö© Ìï®ÏàòÎì§
  const useHeal = useCallback(() => {
    if (cards.heal > 0 && health < 3) {
      setHealth(prev => Math.min(3, prev + 1));
      setCards(prev => ({ ...prev, heal: prev.heal - 1 }));
      addFloatingText('Ï≤¥Î†• ÌöåÎ≥µ Ïπ¥Îìú ÏÇ¨Ïö©! +1');
    }
  }, [cards.heal, health, addFloatingText]);

  const useTrapDisarm = useCallback(() => {
    if (cards.trap_disarm > 0 && pendingTrap) {
      setDisarmedTraps(prev => [...prev, pendingTrap]);
      setCards(prev => ({ ...prev, trap_disarm: prev.trap_disarm - 1 }));
      addFloatingText('Ìï®Ï†ï Ï†úÍ±∞ Ïπ¥Îìú ÏÇ¨Ïö©!');
      setPendingTrap(null);
    }
  }, [cards.trap_disarm, pendingTrap, addFloatingText]);

  const useMultiplierCard = useCallback(() => {
    if (cards.multiplier_card > 0) {
      setMultiplier(prev => prev + 1);
      setCards(prev => ({ ...prev, multiplier_card: prev.multiplier_card - 1 }));
      addFloatingText('Î∞∞Ïàò Ïπ¥Îìú ÏÇ¨Ïö©! +1');
    }
  }, [cards.multiplier_card, addFloatingText]);

  const escape = useCallback(() => {
    if (currentFloor === 0 && playerPos.x === entrancePos.x && playerPos.y === entrancePos.y) {
      setGameOverReason('escape');
      setGameState('gameOver');
    }
  }, [currentFloor, playerPos, entrancePos]);

  const checkGameOver = useCallback(() => {
    if (health <= 0) {
      setGameState('gameOver');
    } else if (score >= DIFFICULTIES[difficulty].target) {
      setGameState('victory');
    }
  }, [health, score, difficulty]);

  const resetGame = useCallback(() => {
    setGameState('menu');
  }, []);

  // Îßµ ÏóêÎîîÌÑ∞ ÌÜ†Í∏Ä
  const toggleMapEditor = useCallback(() => {
    setIsMapEditor(prev => !prev);
  }, []);

  // Îßµ ÏóêÎîîÌÑ∞ÏóêÏÑú ÌÉÄÏùº Î≥ÄÍ≤Ω
  const changeTileInEditor = useCallback((x, y, tileType) => {
    if (!isMapEditor || !selectedTile) return;
    
    setFloors(prev => {
      const newFloors = [...prev];
      newFloors[currentFloor][y][x] = selectedTile;
      return newFloors;
    });

    // ÏïÑÏù¥ÌÖú ÏïÑÏù¥ÏΩò ÏóÖÎç∞Ïù¥Ìä∏
    setItemIcons(prev => {
      const newIcons = [...prev];
      if (!newIcons[currentFloor]) {
        newIcons[currentFloor] = Array(7).fill().map(() => Array(7).fill(null));
      }
      
      if (selectedTile === TILE_TYPES.EMPTY || selectedTile === TILE_TYPES.WALL || 
          selectedTile === TILE_TYPES.ENTRANCE || selectedTile === TILE_TYPES.STAIRS_UP || 
          selectedTile === TILE_TYPES.STAIRS_DOWN) {
        newIcons[currentFloor][y][x] = null;
      } else {
        newIcons[currentFloor][y][x] = { x, y, type: selectedTile };
      }
      
      return newIcons;
    });
  }, [isMapEditor, selectedTile, currentFloor]);

  // useEffectÎì§
  useEffect(() => {
    checkGameOver();
  }, [checkGameOver]);

  useEffect(() => {
    if (playerPos.x === entrancePos.x && playerPos.y === entrancePos.y && currentFloor === 0) {
      if (wasAtEntrance && gameState === 'playing') {
        showConfirmModal(
          'üö™ ÏûÖÍµ¨ ÎèÑÎã¨!',
          'ÏûÖÍµ¨Ïóê ÎèÑÎã¨ÌñàÏäµÎãàÎã§!\nÌÉàÏ∂úÌïòÏãúÍ≤†ÏäµÎãàÍπå?',
          escape,
          () => {}
        );
      }
    }
  }, [playerPos, entrancePos, currentFloor, gameState, wasAtEntrance, showConfirmModal, escape]);

  useEffect(() => {
    const handleKeyPress = (e) => {
      if (gameState !== 'playing') return;
      
      const keyActions = {
        'ArrowUp': () => movePlayer(0, -1),
        'w': () => movePlayer(0, -1),
        'W': () => movePlayer(0, -1),
        'ArrowDown': () => movePlayer(0, 1),
        's': () => movePlayer(0, 1),
        'S': () => movePlayer(0, 1),
        'ArrowLeft': () => movePlayer(-1, 0),
        'a': () => movePlayer(-1, 0),
        'A': () => movePlayer(-1, 0),
        'ArrowRight': () => movePlayer(1, 0),
        'd': () => movePlayer(1, 0),
        'D': () => movePlayer(1, 0),
        'e': escape,
        'E': escape,
        '1': useHeal,
        '2': useTrapDisarm,
        '3': useMap,
        '4': useMultiplierCard
      };
      
      if (keyActions[e.key]) {
        keyActions[e.key]();
      }
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameState, movePlayer, escape, useHeal, useTrapDisarm, useMap, useMultiplierCard]);

  // Î†åÎçîÎßÅ Ìï®ÏàòÎì§
  const getItemIcon = useCallback((x, y) => {
    // Îßµ ÏóêÎîîÌÑ∞ Î™®ÎìúÏù¥Í±∞ÎÇò Í≥µÍ∞úÎêú Ïπ∏Ïù∏ Í≤ΩÏö∞
    if (isMapEditor || (revealed[currentFloor] && revealed[currentFloor][y] && revealed[currentFloor][y][x]) || 
        mapRevealed.some(pos => pos.x === x && pos.y === y)) {
      if (itemIcons[currentFloor] && itemIcons[currentFloor][y] && itemIcons[currentFloor][y][x]) {
        const icon = itemIcons[currentFloor][y][x];
        if (icon) {
          const iconMap = {
            [TILE_TYPES.TREASURE]: 'üíé',
            [TILE_TYPES.BIG_TREASURE]: 'üíç',
            [TILE_TYPES.TRAP]: 'üí£',
            [TILE_TYPES.MULTIPLIER]: '‚≠ê',
            [TILE_TYPES.CARD]: 'üÉè',
            [TILE_TYPES.POTION]: 'üß™',
            [TILE_TYPES.FINAL_TREASURE]: 'üëë'
          };
          return iconMap[icon.type] || '';
        }
      }
    }
    return '';
  }, [currentFloor, revealed, mapRevealed, itemIcons, isMapEditor]);

  // X ÌëúÏãú Î†åÎçîÎßÅ Ìï®Ïàò
  const getBlockedMarker = useCallback((x, y) => {
    const key = `${currentFloor},${x},${y}`;
    return blockedTiles.includes(key) ? '‚ùå' : '';
  }, [currentFloor, blockedTiles]);

  const renderGameBoard = useCallback(() => {
    if (!floors[currentFloor]) return null;
    
    return (
      <div className="game-board">
        <div className="floor-info">
          <h3>{currentFloor + 1}Ï∏µ</h3>
        </div>
        <div className="grid">
          {floors[currentFloor].map((row, y) => (
            <div key={y} className="row">
              {row.map((tile, x) => (
                <div
                  key={`${x}-${y}`}
                  className={`tile ${playerPos.x === x && playerPos.y === y ? 'player' : ''} ${
                    mapRevealed.some(pos => pos.x === x && pos.y === y) ? 'map-revealed' : ''
                  }`}
                  onClick={() => {
                    if (isMapEditor) {
                      // Îßµ ÏóêÎîîÌÑ∞ Î™®ÎìúÏóêÏÑúÎäî ÏÑ†ÌÉùÎêú ÌÉÄÏùºÎ°ú Î≥ÄÍ≤Ω
                      changeTileInEditor(x, y);
                    } else if (gameState === 'playing') {
                      const dx = x - playerPos.x;
                      const dy = y - playerPos.y;
                      if ((Math.abs(dx) === 1 && dy === 0) || (Math.abs(dy) === 1 && dx === 0)) {
                        movePlayer(dx, dy);
                      }
                    }
                  }}
                >
                  {playerPos.x === x && playerPos.y === y ? 'üòÄ' : getVisitedTileDisplay(tile, x, y)}
                  {getItemIcon(x, y) && (
                    <div className="item-icon">
                      {getItemIcon(x, y)}
                    </div>
                  )}
                  {getBlockedMarker(x, y) && (
                    <div className="blocked-marker">
                      {getBlockedMarker(x, y)}
                    </div>
                  )}
                </div>
              ))}
            </div>
          ))}
        </div>
        
        {/* ÌîåÎ°úÌåÖ ÌÖçÏä§Ìä∏ */}
        {floatingTexts
          .filter(text => text.floor === currentFloor)
          .map(text => (
            <div
              key={text.id}
              className="floating-text"
              style={{
                position: 'absolute',
                left: `${text.x * 52 + 10}px`,
                top: `${text.y * 52 + 60}px`,
                zIndex: 1000
              }}
            >
              {text.text}
            </div>
          ))}
      </div>
    );
  }, [currentFloor, floors, playerPos, gameState, mapRevealed, movePlayer, 
      getVisitedTileDisplay, getItemIcon, floatingTexts]);

  // Í≤åÏûÑ ÏÉÅÌÉúÎ≥Ñ Î†åÎçîÎßÅ
  if (gameState === 'menu') {
    return (
      <div className="game-container">
        <h1>üíé LOOT 1004 üíé</h1>
        <div className="difficulty-selector">
          <h3>ÎÇúÏù¥ÎèÑ ÏÑ†ÌÉù</h3>
          {Object.entries(DIFFICULTIES).map(([key, value]) => (
            <button
              key={key}
              onClick={() => setDifficulty(key)}
              className={difficulty === key ? 'selected' : ''}
            >
              {value.name} (Î™©Ìëú: {value.target.toLocaleString()}Ï†ê)
            </button>
          ))}
        </div>
        <button onClick={initializeGame} className="start-button">
          Í≤åÏûÑ ÏãúÏûë
        </button>
      </div>
    );
  }

  if (gameState === 'gameOver') {
    return (
      <div className="game-container">
        <h1>Í≤åÏûÑ Ïò§Î≤Ñ</h1>
        <div className="game-over-info">
          <p>ÏµúÏ¢Ö Ï†êÏàò: {score.toLocaleString()}</p>
          <p>Î™©Ìëú Ï†êÏàò: {DIFFICULTIES[difficulty].target.toLocaleString()}Ï†ê</p>
          <p>ÏÇ¨Ïö©Ìïú Î∞∞Ïàò: x{multiplier.toFixed(1)}</p>
          {gameOverReason === 'death' && <p>üíÄ Ï≤¥Î†•Ïù¥ 0Ïù¥ ÎêòÏóàÏäµÎãàÎã§.</p>}
          {gameOverReason === 'escape' && <p>üèÉ ÌÉàÏ∂úÌñàÏäµÎãàÎã§!</p>}
        </div>
        <button onClick={resetGame} className="reset-button">
          Îã§Ïãú ÏãúÏûë
        </button>
      </div>
    );
  }

  if (gameState === 'victory') {
    return (
      <div className="game-container">
        <h1>üéâ ÏäπÎ¶¨! üéâ</h1>
        <div className="victory-info">
          <p>Î™©Ìëú Ï†êÏàòÎ•º Îã¨ÏÑ±ÌñàÏäµÎãàÎã§!</p>
          <p>ÏµúÏ¢Ö Ï†êÏàò: {score.toLocaleString()}</p>
          <p>ÏÇ¨Ïö©Ìïú Î∞∞Ïàò: x{multiplier.toFixed(1)}</p>
        </div>
        <button onClick={resetGame} className="reset-button">
          Îã§Ïãú ÏãúÏûë
        </button>
      </div>
    );
  }

  return (
    <div className="game-container">
      {/* ÏÉÅÎã® ÏÉÅÌÉúÏ∞Ω */}
      <div className="top-status-bar">
        <div className="status-item">
          <span className="status-label">Ï≤¥Î†•:</span>
          <span className="status-value">{'‚ù§Ô∏è'.repeat(health)}</span>
        </div>
        <div className="status-item">
          <span className="status-label">Ï†êÏàò:</span>
          <span className="status-value">{score.toLocaleString()}</span>
        </div>
        <div className="status-item">
          <span className="status-label">Î∞∞Ïàò:</span>
          <span className="status-value">x{multiplier.toFixed(1)}</span>
        </div>
        <div className="status-item">
          <span className="status-label">Î™©Ìëú:</span>
          <span className="status-value">{DIFFICULTIES[difficulty].target.toLocaleString()}Ï†ê</span>
        </div>
      </div>

      <div className="game-layout">
        {/* Ï§ëÏïô Í≤åÏûÑ Î≥¥Îìú */}
        <div className="game-center">
          {renderGameBoard()}
        </div>

        {/* Ïò§Î•∏Ï™Ω ÏÇ¨Ïù¥ÎìúÎ∞î */}
        <div className="right-sidebar">
          {/* Îßµ ÏóêÎîîÌÑ∞ ÌÜ†Í∏Ä Î≤ÑÌäº */}
          <div className="map-editor-section">
            <button 
              onClick={toggleMapEditor}
              className={isMapEditor ? 'active' : ''}
              style={{ 
                backgroundColor: isMapEditor ? '#4CAF50' : '#666',
                color: 'white',
                padding: '10px',
                border: 'none',
                borderRadius: '5px',
                cursor: 'pointer',
                marginBottom: '10px'
              }}
            >
              {isMapEditor ? 'Îßµ ÏóêÎîîÌÑ∞ Ï¢ÖÎ£å' : 'Îßµ ÏóêÎîîÌÑ∞ ÏãúÏûë'}
            </button>
          </div>

          {isMapEditor ? (
            <div className="map-editor-panel">
              <h4>Îßµ ÏóêÎîîÌÑ∞</h4>
              <div className="tile-selector">
                <h5>ÌÉÄÏùº ÏÑ†ÌÉù:</h5>
                <div className="tile-buttons">
                  <button onClick={() => setSelectedTile(TILE_TYPES.EMPTY)}>‚¨ú Îπà Í≥µÍ∞Ñ</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.WALL)}>üß± Î≤Ω</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.TREASURE)}>üíé Î≥¥Î¨º</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.BIG_TREASURE)}>üíç ÎåÄÎ≥¥Î¨º</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.TRAP)}>üí£ Ìï®Ï†ï</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.MULTIPLIER)}>‚≠ê Î∞∞Ïàò</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.CARD)}>üÉè Ïπ¥Îìú</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.POTION)}>üß™ Ìè¨ÏÖò</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.STAIRS_UP)}>‚¨ÜÔ∏è ÏúÑ Í≥ÑÎã®</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.STAIRS_DOWN)}>‚¨áÔ∏è ÏïÑÎûò Í≥ÑÎã®</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.ENTRANCE)}>üö™ ÏûÖÍµ¨</button>
                  <button onClick={() => setSelectedTile(TILE_TYPES.FINAL_TREASURE)}>üëë ÏµúÏ¢ÖÎ≥¥Î¨º</button>
                </div>
                <p>ÏÑ†ÌÉùÎêú ÌÉÄÏùº: {selectedTile || 'ÏóÜÏùå'}</p>
                <p>ÌÉÄÏùºÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Î∞∞ÏπòÌïòÏÑ∏Ïöî</p>
              </div>
            </div>
          ) : (
            <>
              <div className="cards-section">
                <h4>Ïπ¥Îìú</h4>
                <div className="card-buttons">
                  <button onClick={useHeal} disabled={cards.heal === 0 || health >= 3}>
                    Ï≤¥Î†• ÌöåÎ≥µ ({cards.heal})
                  </button>
                  <button onClick={useTrapDisarm} disabled={cards.trap_disarm === 0 || !pendingTrap}>
                    Ìï®Ï†ï Ï†úÍ±∞ ({cards.trap_disarm})
                  </button>
                  <button onClick={useMap} disabled={cards.map === 0}>
                    ÏßÄÎèÑ ({cards.map})
                  </button>
                  <button onClick={useMultiplierCard} disabled={cards.multiplier_card === 0}>
                    Î∞∞Ïàò Ï¶ùÍ∞Ä ({cards.multiplier_card})
                  </button>
                </div>
              </div>
              
              <div className="controls-section">
                <h4>Ï°∞ÏûëÎ≤ï</h4>
                <div>Î∞©Ìñ•ÌÇ§ ÎòêÎäî WASD: Ïù¥Îèô</div>
                <div>E: ÌÉàÏ∂ú</div>
                <div>1-4: Ïπ¥Îìú ÏÇ¨Ïö©</div>
              </div>
              
              {pendingTrap && (
                <div className="warning">
                  ‚ö†Ô∏è Ìï®Ï†ïÏù¥ ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§! Ìï®Ï†ï Ï†úÍ±∞ Ïπ¥ÎìúÎ•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.
                </div>
              )}
            </>
          )}
        </div>
      </div>

      {/* Ïª§Ïä§ÌÖÄ ÌôïÏù∏Ï∞Ω */}
      {showModal && (
        <div className="dungeon-modal">
          <div className="dungeon-modal-content">
            <div className="dungeon-modal-title">{modalConfig.title}</div>
            <div className="dungeon-modal-message">{modalConfig.message}</div>
            <div className="dungeon-modal-buttons">
              <button className="dungeon-modal-btn confirm" onClick={handleModalConfirm}>
                ÌôïÏù∏
              </button>
              <button className="dungeon-modal-btn cancel" onClick={handleModalCancel}>
                Ï∑®ÏÜå
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

export default Loot1004Game;
